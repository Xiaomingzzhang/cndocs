var documenterSearchIndex = {"docs":
[{"location":"non_smooth_one.html#Non-smooth-one-dimensional-manifolds","page":"Non-smooth one-dimensional manifolds","title":"Non-smooth one-dimensional manifolds","text":"","category":"section"},{"location":"non_smooth_one.html#Piecewise-smooth-ODE-example","page":"Non-smooth one-dimensional manifolds","title":"Piecewise smooth ODE example","text":"","category":"section"},{"location":"non_smooth_one.html#Impact-system-example","page":"Non-smooth one-dimensional manifolds","title":"Impact system example","text":"","category":"section"},{"location":"non_smooth_one.html#ODE-system-with-both-piecewise-smoothness-and-impacts","page":"Non-smooth one-dimensional manifolds","title":"ODE system with both piecewise smoothness and impacts","text":"","category":"section"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Modules = [InvariantManifolds]\nOrder   = [:type, :function]","category":"page"},{"location":"api.html#InvariantManifolds.BilliardV","page":"API","title":"InvariantManifolds.BilliardV","text":"BilliardV\n\nA callable struct to represent a vector field with multiple hyper surfaces such that the flow jump when hits these hyper surfaces.\n\nFields\n\nf is the vector field, of type f(x,p,t), and its output is a SVector;\nhypers is tuple of hyper surfaces:(h1,h2,...), h1(x,p,t);\nirules is tuple of rules on hyper surfaces:(r1,r2,r3,...).\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.FlawPoint","page":"API","title":"InvariantManifolds.FlawPoint","text":"FlawPoint{N,T}\n\nFlawPoint is a struct to record the points that don't satisfy the angle and distance request while the  program has reached the minimum arc length.\n\nFields\n\npoint flaw point in the process of continuation;\nα the angle recorded;\nd the distance recorded.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSOneDManifold","page":"API","title":"InvariantManifolds.NSOneDManifold","text":"NSOneDManifold{F,S,N,T}\n\nNSOneDManifold is a struct contains all the information of the non-smooth one-dimensional numerical manifold.\n\nFields\n\nprob the problem NSOneDManifoldProblem;\ndata the numerical data that should be Vector{Vector{Vector{S}}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSOneDManifoldProblem","page":"API","title":"InvariantManifolds.NSOneDManifoldProblem","text":"NSOneDManifoldProblem{F,T}\n\nNSOneDManifoldProblem is a struct to contain the main information for continuing the non-smooth one-dimensional manifold of the time-T-map of a non-smooth ODE.\n\nFields\n\nf the struct NSSetUp;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\nϵ the max value of the following expression: maxH(x_0T)H(x_1T) where H(xt) is the hypersurface the manifold cross, x_0 and x_1 are points before and after the cross, T is the end of the time-T-map (from 0 to T).\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are NSOneDManifoldProblem(f) and NSOneDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSSetUp","page":"API","title":"InvariantManifolds.NSSetUp","text":"NSSetUp{T}\n\nNSSetUp is a struct to contain all the information needed in continuing the manifold of non-smooth ODE.\n\nFields\n\nf the Non-smooth vector field, like PiecewiseV;\ntimespan the time span of time-T-map;\ntimetmap the time-t-map of non-smooth ODE, which maps a NSState and parameters of ODE to a NSState.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSSolution","page":"API","title":"InvariantManifolds.NSSolution","text":"NSSolution{N,T<:Number}\n\nThe NSSolution is a struct to contain all information of the solution of a non-smooth ODE system.\n\nFields\n\nsol ODESolution solved by OrdinaryDiffEq;\nevent_t the times when events happen;\nevent_state the solution's state when events happen;\nevent_at is a vector that contains integers indicating which event happen.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSState","page":"API","title":"InvariantManifolds.NSState","text":"NSState{N,T<:Number} <: AbstractVector{T}\n\nThe struct NSState is to record the events data for a time-T-map.\n\nFields\n\nstate the final state of the time-T-map;\nevent_at is a integer vector that contains the history of the events happened.\n\nThe construction of NSState allows to interpolate vectors consisting of NSState. Currently, LinearInterpolation, CubicSpline, and QuadraticInterpolation in DataInterpolations.jl are supported.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSVTwoDManifold","page":"API","title":"InvariantManifolds.NSVTwoDManifold","text":"NSVTwoDManifold{F,S,N,T}\n\nNSVTwoDManifold is a struct contains all the information of the non-smooth two-dimensional numerical manifold of an autonomous vector field.\n\nFields\n\nprob the problem NSVTwoDManifoldProblem;\ndata the numerical data that should be Vector{Vector{S}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSVTwoDManifoldProblem","page":"API","title":"InvariantManifolds.NSVTwoDManifoldProblem","text":"NSVTwoDManifoldProblem{F,T}\n\nNSVTwoDManifoldProblemVTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of an autonomous vector field.\n\nFields\n\nf the NSSetUp of a nonsmooth vector field;\npara the parameters of the time flow map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\nϵ the max value of the following expression: maxH(x_0T)H(x_1T) where H(xt) is the hypersurface of the manifold cross, x_0 and x_1 are points before and after the cross, T is the end of the time-T-map (from 0 to T).\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are NSVTwoDManifoldProblem(f) and NSVTwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.ODESolver","page":"API","title":"InvariantManifolds.ODESolver","text":"ODESolver{F1,F2,T}\n\nA wrapper struct for solving ordinary differential equations (ODEs).\n\nFields\n\nf: Vector field function of the ODE system in the form f(x,p,t)\ntimespan: Time interval for solving the ODE, of type Tuple{T,T}\nalg: The numerical algorithm used for solving the ODE\nabstol: Absolute tolerance for the numerical solver\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.OneDManifold","page":"API","title":"InvariantManifolds.OneDManifold","text":"OneDManifold{F,S,N,T}\n\nOneDManifold is a struct contains all the information of the one-dimensional numerical manifold.\n\nFields\n\nprob the problem OneDManifoldProblem;\ndata the numerical data that should be Vector{Vector{S}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.OneDManifoldProblem","page":"API","title":"InvariantManifolds.OneDManifoldProblem","text":"OneDManifoldProblem{F,T}\n\nOneDManifoldProblem is a struct to contain the main information for continuing the one-dimensional manifold of a nonlinear map.\n\nFields\n\nf the nonlinear map, which should has the form f(x,p) and return a SVector;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are OneDManifoldProblem(f) and OneDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.PiecewiseImpactV","page":"API","title":"InvariantManifolds.PiecewiseImpactV","text":"PiecewiseImpactV\n\nA callable struct to represent a vector field with both piecewise non-smoothness and impacts.\n\nfs is a tuple of smooth vector fields in different regions.\nregions is a tuple of the region functions: (r1,r2,...), where r1(x,p,t) should return a Bool value to indicate that x is in this region or not.\nhypers is a tuple of the hyper surfaces separating the regions.\nrules is a tuple of rules on hyper surfaces:(r1,r2,r3,...). Note that for hypersurfaces that only switch between two vector fields, we can set r1=id.\nregions is a tuple of the region functions: (r1,r2,...), where r1(x,p,t) should return a Bool value to indicate that x is in this region or not.\nidxs is a vector of integer to indicate hypersurfaces with impact effects.\nn is a integer to switch between vector fields. Default to be zero.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.PiecewiseV","page":"API","title":"InvariantManifolds.PiecewiseV","text":"PiecewiseV\n\nA callable struct to represent a piecewise smooth vector field. \n\nFields\n\nfs is a tuple of smooth vector fields in different regions.\nregions is a tuple of the region functions: (r1,r2,...), where r1(x,p,t) should return a Bool value to indicate that x is in this region or not.\nhypers is a tuple of the hyper surfaces separating the regions.\nn is a integer to switch between vector fields. Default to be zero.\n\nExample\n\nusing StaticArrays, InvariantManifolds\nf1(x,p,t)=SA[x[2],-2x[1]]\nf2(x,p,t)=SA[x[2],-x[1]]\ndom1(x,p,t)=x[1]>0\ndom2(x,p,t)=x[2]<0\nhyper(x,p,t)=x[1]\nPiecewiseV((f1,f2),(dom1,dom2),(hyper,))\n\nThe above codes generate a piecewise smooth vector field, which when x[1]>0 is f1, and when x[2]<0 is f2. The hyper surface separating these smooth vector fields is x[1]=0.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.Saddle","page":"API","title":"InvariantManifolds.Saddle","text":"Saddle{N,T,S}\n\nSaddle is a struct to contain the information of a saddle point needed in continuing the manifold of non-smooth ODE. For an ODE's saddle, this struct can be constructed by the function findsaddle.\n\nFields\n\nsaddle the location of the saddle point;\nunstable_directions the unstable directions;\nunstable_eigen_values eigenvalues of the linearized map in the saddle at the unstable eigenvectors.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.TwoDManifold","page":"API","title":"InvariantManifolds.TwoDManifold","text":"TwoDManifold{F,S,N,T}\n\nTwoDManifold is a struct contains all the information of the two-dimensional numerical manifold of a nonlinear map.\n\nFields\n\nprob the problem TwoDManifoldProblem;\ndata the numerical data that should be Vector{S}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.TwoDManifoldProblem","page":"API","title":"InvariantManifolds.TwoDManifoldProblem","text":"TwoDManifoldProblem{F,T}\n\nTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of a nonlinear map.\n\nFields\n\nf the nonlinear map, which should has the form f(x,p) and return a SVector;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndcircle the maximum distance between circles when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are TwoDManifoldProblem(f) and TwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.VTwoDManifold","page":"API","title":"InvariantManifolds.VTwoDManifold","text":"VTwoDManifold{F,S,N,T}\n\nVTwoDManifold is a struct contains all the information of the two-dimensional numerical manifold of an autonomous vector field.\n\nFields\n\nprob the problem VTwoDManifoldProblem;\ndata the numerical data that should be Vector{S}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.VTwoDManifoldProblem","page":"API","title":"InvariantManifolds.VTwoDManifoldProblem","text":"VTwoDManifoldProblem{F,T}\n\nVTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of an autonomous vector field.\n\nFields\n\nf the time flow map of the vector field, which should has the form f(x,p) and return a SVector; note that the vector field should be regularized, e.g., dotx=v(x) should be rewritten as dotx=v(x)sqrt1+v(x);\npara the parameters of the time flow map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are VTwoDManifoldProblem(f) and VTwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.addcircles!-NTuple{8, Any}","page":"API","title":"InvariantManifolds.addcircles!","text":"InvariantManifolds.addcircles!(f, para, d, circles, dsmin, αmax, dcircle, flawpoints; interp=LinearInterpolation)\n\nAdds and refines circles in the two-dimensional manifold computation by iterating the map and ensuring proper point distribution.\n\nArguments\n\nf: The nonlinear map function\npara: Vector of parameters for the map\nd: Maximum allowed distance between points in a circle\ncircles: Vector of interpolated curves representing the current circles\ndsmin: Minimum allowed arc length between points\nαmax: Maximum allowed angle between consecutive points\ndcircle: Maximum allowed distance between consecutive circles\nflawpoints: Vector to store problematic points during computation\ninterp: Interpolation method (default: LinearInterpolation)\n\nReturns\n\nA vector of new interpolated curves representing the refined circles after one iteration of the map.\n\nDetails\n\nThe function performs two main steps:\n\nIterates each circle forward under the map and refines point distribution within each circle\nAdds intermediate circles where the distance between consecutive circles exceeds dcircle\n\nPoints are added to maintain proper spacing and curvature constraints specified by d and αmax.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Array{StaticArraysCore.SVector{N, T}, 1}, Vector{T}, Any, Any, Any}} where {N, T}","page":"API","title":"InvariantManifolds.addpoints!","text":"InvariantManifolds.addpoints!(f, p, d, oldcurve, newu, olds, dsmin, αmax, flawpoints)\n\nAdd points to ensure proper spacing and curvature along a one-dimensional manifold curve.\n\nArguments\n\nf: The nonlinear map function\np: Parameters for the nonlinear map\nd: Maximum allowed distance between consecutive points\noldcurve: Previous curve interpolation\nnewu::Vector{SVector{N,T}}: New points to be processed\nolds::Vector{T}: Parameter values of the points\ndsmin: Minimum allowed arc length between points\nαmax: Maximum allowed angle between consecutive segments\nflawpoints: Vector to store problematic points that don't meet criteria\n\nDetails\n\nThe function iteratively processes points, adding new ones when:\n\nThe distance between consecutive points exceeds d\nThe angle between consecutive segments exceeds αmax\nThe arc length is greater than dsmin\n\nIf a point fails these criteria and the minimum arc length is reached, it's recorded as a flaw point.\n\nReturns\n\nVector of parameter values for the new points\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.findsaddle-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, StaticArraysCore.SVector{N, T}, Any}} where {N, T}","page":"API","title":"InvariantManifolds.findsaddle","text":"findsaddle(v, dv, timespan, x, p)\n\nfindsaddle is a function to find the saddle of the time-T-map of smooth ODE systems, by using the Newton's method.\n\nParameters\n\nv the vector field, which should be the form f(x,p,t) and return a SVector;\ndv the Jacobi matrix function of v, which should should be the form dv(x,p,t) and return a SMatrix;\ntimespan the time span of the time-T-map;\nx the initial point to iterate.\n\nKeyword arguments\n\nn maximum iterate times, default to be 100;\nabstol absolute tolerance for the fixed point, default to be 1e-8;\nalg the algorithm used to solve the ODE, default to be Vern9().\n\nReturns\n\nA Saddle object, which contains the fixed point and the directions of the stable manifold.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.gen_disk-Union{Tuple{Saddle{N, T, S}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S}","page":"API","title":"InvariantManifolds.gen_disk","text":"gen_disk(p, times)\n\ngen_disk is a function to generate circles around the saddle, which represented as the local manifold.\n\nParameters\n\np the struct Saddle which should contains two unstable directions; the complex eigenvalues and eigenvectors are allowed.\n\nKeyword arguments\n\ntimes the iteration time, default to be 1; for the computation of invariant manifolds of nonlinear map, this parameter is needed to adjust the torsion in different directions in the process of continuation.\nn the number of point in each circle, default to be 150;\nd the max distance between points in a single circle, default to be 0.002;\nr the size of the disk, default to be 0.05;\ncircles the number of the circles, default to be 10.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.gen_segment-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any}} where {N, T}","page":"API","title":"InvariantManifolds.gen_segment","text":"gen_segment(saddle, direction)\n\nGenerating n points at saddle in the direction, with length d, with default n=150 and d=0.01. Another Convenient consturctor is gen_segment(p::Saddle).\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.grow!-Tuple{InvariantManifolds.OneDManifold}","page":"API","title":"InvariantManifolds.grow!","text":"grow!(manifold)\n\nOne time iteration to grow the manifold.\n\nParameters\n\nmanifold the manifold struct.\n\nKeyword argument\n\ninterp the interpolation method used, default to be LinearInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.growmanifold-Tuple{OneDManifoldProblem, Any, Any}","page":"API","title":"InvariantManifolds.growmanifold","text":"growmanifold(prob, points, N)\n\nThis is the mani function to continuate the numerical manifolds. Its output is a manifold struct.\n\nParameters\n\nprob the problem such as OneDManifoldProblem.\npoints the points in the local manifold. For one dimensional manifolds, these points should be a Vector{SVector} and the start point should be the saddle. For two dimensional manifolds, these points should be a Vector{Vector{S}} and its first element should like [saddle, saddle, saddle]. Note that in the both cases, the functions gen_segment and gen_disk can generate these points easily.\nN the number of iterations.\n\nKeyword argument\n\ninterp the interpolation method used, default to be LinearInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.initialize-Union{Tuple{T}, Tuple{N}, Tuple{OneDManifoldProblem, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}","page":"API","title":"InvariantManifolds.initialize","text":"initialize(prob, points)\n\nThis is a function to initialize the continuation process. Its output is a manifold struct.\n\nParameters\n\nprob the problem such as OneDManifoldProblem.\npoints the points in the local manifold. For one dimensional manifolds, these points should be a Vector{SVector} and the start point should be the saddle. For two dimensional manifolds, these points should be a Vector{Vector{S}} and its first element should like [saddle, saddle, saddle]. Note that in the both cases, the functions gen_segment and gen_disk can generate these points easily.\n\nKeyword argument\n\ninterp the interpolation method used, default to be LinearInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.kd_distence-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}","page":"API","title":"InvariantManifolds.kd_distence","text":"InvariantManifolds.kd_distence\n\nThe function to measure the distance between two circles by using the package NearestNeighbors.jl.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.ns_addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Any, Array{NSState{N, T}, 1}, Vector{T}, Vararg{Any, 5}}} where {N, T}","page":"API","title":"InvariantManifolds.ns_addpoints!","text":"InvariantManifolds.ns_addpoints!(tmap, p, d, dsmin, oldcurve, newu, olds, αmax, tend, hypers, ϵ, flawpoints) -> Vector{T}\n\nAdd points to ensure proper spacing and accuracy when computing the non-smooth one-dimensional manifold.\n\nArguments\n\ntmap: Time map function that evolves states forward\np: Vector of parameters\nd: Maximum allowed distance between consecutive points\ndsmin: Minimum allowed arc length between points\noldcurve: Previous curve data used for interpolation\nnewu: Vector of new states to be processed\nolds: Vector of arc length parameters\nαmax: Maximum allowed angle between consecutive segments\ntend: End time of the time map\nhypers: Vector of hypersurface functions\nϵ: Maximum allowed error in hypersurface intersection\nflawpoints: Vector to store problematic points encountered\n\nReturns\n\nVector of arc length parameters for the processed points\n\nDetails\n\nThe function adaptively adds points to maintain:\n\nMaximum distance d between consecutive points\nMaximum angle αmax between segments\nAccuracy ϵ at hypersurface intersections\n\nIf constraints cannot be satisfied within dsmin, points are marked as flaws.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.ns_solver-Tuple{PiecewiseV, Vararg{Any, 4}}","page":"API","title":"InvariantManifolds.ns_solver","text":"ns_solver(v::T, para, timespan, alg, N, T)\n\nThe function ns_solver is similar to timetmap. The output of this function is a function which maps a SVector to a NSSolution. This NSSolution contain all data of an non-smooth ODE solution.\n\nParameters\n\nv vector fields like PiecewiseV or BilliardV.\npara the parameter of the vector field.\ntimespan the time span of the time-T-map.\nalg algorithm in OrdinaryDiffEq to solve ODE.\nN the dimension of the vector field.\nT number type used in computation.\n\nTo ensure type stable, the numbers in para and timespan should be type of T. The last two parameters have to be specified, since we need to store the event data. You can also pass the keywords of solve of OrdinaryDiffEq to this function,  except the callback and saving related keywords.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.setmap-Union{Tuple{T}, Tuple{PiecewiseV, Tuple{T, T}, Any}} where T","page":"API","title":"InvariantManifolds.setmap","text":"setmap(v, timespan::Tuple{T,T}, alg; extra...) where {T}\n\nThe function setmap is to get a NSSetUp.\n\nParameters\n\nv a nonsmooth vector field like PiecewiseV or BilliardV.\ntimespan the time span of the time-T-map.\nalg algorithm in OrdinaryDiffEq to solve ODE.\n\nTo ensure type stable, the numbers in timespan should be type of T.\n\nKeyword arguments\n\nFor vector fields PiecewiseV and PiecewiseImpactV, we have two special keyword arguments:\n\ncross_time= 1//20 when the solution sol hits the hypersurface at time t, we need to know which domain it enters. We choose the state sol(t+cross_time) to determine which domain it enters.\nregion_detect=_region_detect the region detect function to determine which domain the state in.\n\nYou can also pass the keywords of solve of OrdinaryDiffEq to this function,  except the callback and saving related keywords.\n\n\n\n\n\n","category":"method"},{"location":"non_smooth_two.html#Non-smooth-two-dimensional-manifold-for-non-smooth-autonomous-vector-field","page":"Non-smooth two-dimensional manifolds","title":"Non-smooth two-dimensional manifold for non-smooth autonomous vector field","text":"","category":"section"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html#Unstable-manifold-of-Henon-map","page":"Examples","title":"Unstable manifold of Henon map","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Consider the Henon map:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"beginaligned\nx=1-alpha x^2+y\ny=beta x\nendaligned","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"where alpha=14beta=03. This map has a saddle located at (06313544770895048 018940634312685142), and its unstable eigenvector is (-09880577559947047 015408397327012555). ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"To compute the unstable manifolds of the saddle numerically, InvariantManifolds.jl just needs a segment of unstable manifold, whose start point is the saddle. It's resonable to choose a short unstable eigenvector as the segment. You don't have to shorten the eigenvector started at the saddle yourself. We provide a function segment to do this automatically. The segment can generate equal distributed n points at one point, with given length and direction.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using InvariantManifolds, StaticArrays\n\nfunction henonmap(x, p)\n    y1 = 1 - p[1] * x[1]^2 + x[2]\n    y2 = p[2] * x[1]\n    SA[y1, y2]\nend\n\nhenonmap2(x, p)=henonmap(henonmap(x, p), p)\n\n# For technical reason, we have to use the double iteration of the map, since the eigenvalue is less than -1.\n\nseg = segment(SA[0.6313544770895048, 0.18940634312685142], SA[-0.9880577559947047, 0.15408397327012555], 150, 0.01)\nresult = generate_curves(henonmap2, SA[1.4, 0.3], seg, 0.001, 8)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This package does not provide any function to plot the manifolds. However, it's simple to plot it using the stardard julia ploting library.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"To do this, just run","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using GLMakie\nfunction manifold_plot(v::Vector{IterationCurve})\n    figure = Figure()\n    axes = Axis(figure[1,1])\n    for k in eachindex(v)\n        data = v[k].pcurve.u\n        lines!(axes, first.(data), last.(data))\n    end\n    figure\nend\nmanifold_plot(result)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"../figs/henon.png\" width=\"600\"/>","category":"page"},{"location":"examples.html#Unstable-manifold-of-the-periodic-perturbed-system:","page":"Examples","title":"Unstable manifold of the periodic perturbed system:","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Consider the Duffing equation with periodic perturbation:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"beginaligned\ndotx=y\ndoty=x-x^3+gamma cos(t)\nendaligned","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"When gamma=0, the system has a saddle located at (00). After the small periodic perturbation, this saddle becomes a saddle periodic orbit, i.e., a saddle of the map Txmapsto phi(X2pi0), where phi(Xtt_0) is the solution of system with initial condition X(t_0)=XinmathbbR^2. Fortunately, we can use the solution of the variational equation to get the jacobian matrix of T. The map T's saddle's location and unstable direction can also be obtained numerically.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, GLMakie\n# Duffing Equation\n\nf(x, p, t) = SA[x[2], x[1] - x[1]^3 + p[1]*cos(t)]\n\n# First find the fixed point and its unstable direction by using the Newton iteration.\n\nfunction timemap(x,p)\n    prob = ODEProblem{false}(f, x, (0.0, 2pi), p)\n    solve(prob, Vern9())[end]\nend\n\n# Solving the variational equation to get the jacobian matrix.\n\nfunction jac(x, p)\n    prob = ODEProblem{false}(f, x, (0.0, 2pi), p)\n    sol = solve(prob, Vern9())\n    function df(x, p, t)\n        SA[0 1; 1-3*(sol(t)[1])^2 0] * x\n    end\n    ii = SA[1.0 0.0; 0.0 1.0]\n    nprob = ODEProblem{false}(df, ii, (0.0, 2pi), p)\n    solve(nprob, Vern9())[end]\nend\n\n# Newton's iteration to get the saddle's location.\n\nfunction newton(x, p; n=100, atol=1e-8)\n    xn = x - inv(jac(x, p) - I) * (timemap(x, p) - x)\n    data = typeof(x)[x, xn]\n    i = 1\n    while norm(data[2] - data[1]) > atol && i <= n\n        data[1] = data[2]\n        data[2] = data[1] - inv(jac(data[1], p) - I) * (timemap(data[1], p) - data[1])\n        i = i + 1\n    end\n    if norm(data[2] - data[1]) < atol\n        println(\"Fixed point found successfully:\")\n        data[2]\n    else\n        println(\"Failed to find a fixed point after $n times iterations. The last point is:\")\n        data[2]\n    end\nend\n\nfunction manifold_plot(v)\n    figure = Figure()\n    axes = Axis(figure[1,1])\n    for k in eachindex(v)\n        data = v[k].pcurve.u\n        lines!(axes, first.(data), last.(data))\n    end\n    figure\nend\n\npara = [0.1]\nfixedpoint = newton(SA[-0.05, 0.0], para)\nunstable_direction = eigen(jac(fixedpoint, para)).vectors[:, 2]\nseg = segment(fixedpoint, unstable_direction, 150, 0.01)\nresult = generate_curves(timemap, para, seg, 0.002, 3)\nmanifold_plot(result)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"../figs/duffing.png\" width=\"600\"/>","category":"page"},{"location":"examples.html#Lorenz-manifold","page":"Examples","title":"Lorenz manifold","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In this example, we will consider the well known Lorenz's equation. With classical parameters, the fixed point origin has two linear independent stable direction. Hence, there exists a two-dimensional stable manifolds of the origin, the so called Lorenz manifold. The function generate_surface mainly needs two parameter to compute such stable manifolds. The first parameter is the time-T-map of the system, where T0. Moreover, the original vector field has to be rescaled to ensure the uniform extension of the flow. The second parameter is the two linear independent stable direction. See the blew codes for more details.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, GLMakie\n\n# First define the rescaled lorenz vector field and its time-T-map\n\nfunction lorenz(x, p, t)\n    σ, ρ, β = p\n    v = SA[σ*(x[2]-x[1]),\n        ρ*x[1]-x[2]-x[1]*x[3],\n        x[1]*x[2]-β*x[3]\n    ]\n    v / sqrt(1 + norm(v)^2)\nend\n\nfunction lorenz_map(x, p)\n    prob = ODEProblem{false}(lorenz, x, (0.0, -2.0), p)\n    sol = solve(prob, Tsit5())\n    sol[end]\nend\n\nfunction eigenv(p)\n    σ, ρ, β = p\n    (SA[0.0, 0.0, 1.0], SA[-(-1 + σ + sqrt(1 - 2 * σ + 4 * ρ * σ + σ^2))/(2*ρ), 1, 0])\nend\n\nsecond(x) = x[2]\n\nfunction manifold_plot(annulus)\n    fig = Figure()\n    axes = LScene(fig[1, 1], show_axis=false,scenekw = (backgroundcolor=:white, clear=true))\n    for i in eachindex(annulus)\n        points = annulus[i].outer.pcurve.u\n        scatter!(axes, first.(points), second.(points), last.(points), fxaa=true)\n    end\n    fig\nend\npara = [10, 28, 9 / 3]\nlorenz_manifold = generate_surface(lorenz_map, para, SA[0.0, 0.0, 0.0], eigenv(para)..., 120, 1, 1)\nmanifold_plot(lorenz_manifold)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"../figs/lorenz.png\" width=\"600\"/>","category":"page"},{"location":"examples.html#Unstable-manifold-of-the-piecewise-smooth-ODE's-time-T-map","page":"Examples","title":"Unstable manifold of the piecewise smooth ODE's time-T-map","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Consider a simple piecewise smooth system:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"beginaligned\ndotx=y\ndoty=f(x) + epsilon sin(2pi t)\nendaligned","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"where","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"f(x) =\nbegincases\n-k_1  textif  x  -d\nk_2  textif  -dxd\n-k_3  textif  x  d\nendcases","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"where k_1k_2k_3d0 are positive parameters. We are going to compute the time-1-map' unstable manifolds of saddle located near (00) when epsilon is small.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"First, we define a piecewise smooth vector field:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, GLMakie\n\nf1(x, p, t) = SA[x[2], p[1]*x[1]+p[4]*sin(2pi * t)]\n\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[4]*sin(2pi * t)]\n\nf3(x, p, t) = SA[x[2], -p[3]*x[1]+p[4]*sin(2pi * t)]\n\nhyper1(x, p, t) = x[1] - p[5]\n\nhyper2(x, p, t) = x[1] + p[5]\n\ndom1(x, p, t) = -p[5] < x[1] < p[5]\n\ndom2(x, p, t) = x[1] > p[5]\n\ndom3(x, p, t) = x[1] < -p[5]\n\nvectorfield = PiecewiseV((f1, f2, f3), (dom1, dom2, dom3), (hyper1, hyper2), 0)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The parameters pass to PiecewiseV are vector fields, their definition domains, and the hyper surfaces separating these domains. See PiecewiseV for more details.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Then we set the information needs when computing the time-1-map:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"setup = setmap(vectorfield, (0.0, 1.0), Tsit5(), 2, Float64)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"See setmap for the meaning of parameters of this function. For small epsilon, the amplitude of the saddle periodic orbit is small so that the orbit is in domain dom1. So we can still using the method of variational equation to compute the saddle's location.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"function timemap(x,p)\n    prob = ODEProblem{false}(f1, x, (0.0, 1.0), p)\n    solve(prob, Vern9())[end]\nend\n\nfunction jac(x,p)\n    prob = ODEProblem{false}(f1, x, (0.0, 1.0), p)\n    sol = solve(prob, Vern9())\n    function df(x, p, t)\n        SA[0 1; p[1] 0] * x\n    end\n    ii = SA[1.0 0.0; 0.0 1.0]\n    nprob = ODEProblem{false}(df, ii, (0.0, 1.0), p)\n    solve(nprob, Vern9())[end]\nend\n\nfunction newton(x,p; n=100, atol=1e-8)\n    xn = x - inv(jac(x,p) - I) * (timemap(x,p) - x)\n    data = [x, xn]\n    i = 1\n    while norm(data[2] - data[1]) > atol && i <= n\n        data[1] = data[2]\n        data[2] = data[1] - inv(jac(data[1],p) - I) * (timemap(data[1],p) - data[1])\n    end\n    if norm(data[2] - data[1]) < atol\n        println(\"Fixed point found successfully:\")\n        data[2]\n    else\n        println(\"Failed to find a fixed point after $n times iterations. The last point is:\")\n        data[2]\n    end\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Then we define the parameters and try to find the saddle:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"para = [2, 5, 5, 0.6, 2]\nfixedpoint= newton(SA[0.0, 0.0],para)\nunstable_direction = eigen(jac(fixedpoint,para)).vectors[:,2]","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"As before, we compute the manifold and plot it using GLMakie. Noting that the data structures of result is slightly different from examples before.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"seg = segment(fixedpoint, unstable_direction, 150, 0.05)\nresult = generate_curves(setup, para, seg, 0.01, 9)\n\nfunction manifold_plot(result)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(result)\n        for j in eachindex(result[k])\n            data=result[k][j].pcurve.u\n            lines!(axes,first.(data),last.(data))\n        end\n    end\n    fig\nend\n\nmanifold_plot(result)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"../figs/piecewise.png\" width=\"600\"/>","category":"page"},{"location":"examples.html#Unstable-manifold-of-the-impact-inverted-pendulum's-time-T-map","page":"Examples","title":"Unstable manifold of the impact inverted pendulum's time-T-map","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Consider an inverted pendulum with two side walls and a small periodic perturbation:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"beginaligned\ndotx= y\ndoty= sin(x) - epsilon cos(2pi t)\nendaligned","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"When x=xi or x=-xi, we have yrightarrow - ry.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The procedure for computing such system's manifold is similar with before, we just give codes here:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, GLMakie\n\nf(x, p, t) = SA[x[2], sin(x[1])-p[1]*cos(2 * pi * t)]\n\nhyper1(x, p, t) = x[1] + p[2]\n\nhyper2(x, p, t) = x[1] - p[2]\n\nrule1(x, p, t) = SA[x[1], -p[3]*x[2]]\n\nrule2(x, p, t) = SA[x[1], -p[3]*x[2]]\n\nvectorfield = BilliardV(f, (hyper1, hyper2), (rule1, rule2))\n\nsetup = setmap(vectorfield, (0.0, 1.0), Vern9(), 2, Float64)\n\n# First find the fixed point and its unstable direction\n\nfunction timemap(x,p)\n    prob = ODEProblem{false}(f, x, (0.0, 1.0), p)\n    sol = solve(prob, Vern9())[end]\nend\n\nfunction jac(x, p)\n    prob = ODEProblem{false}(f, x, (0.0, 1.0), p)\n    sol = solve(prob, Vern9())\n    function df(x, p, t)\n        SA[0 1; cos(sol(t)[1]) 0] * x\n    end\n    ii = SA[1.0 0.0; 0.0 1.0]\n    nprob = ODEProblem{false}(df, ii, (0.0, 1.0), p)\n    solve(nprob, Vern9())[end]\nend\n\nfunction newton(x, p; n=100, atol=1e-12)\n    xn = x - inv(jac(x, p) - I) * (timemap(x, p) - x)\n    data = typeof(x)[x, xn]\n    i = 1\n    while norm(data[2] - data[1]) > atol && i <= n\n        data[1] = data[2]\n        data[2] = data[1] - inv(jac(data[1], p) - I) * (timemap(data[1], p) - data[1])\n        i = i + 1\n    end\n    if norm(data[2] - data[1]) < atol\n        println(\"Fixed point found successfully:\")\n        data[2]\n    else\n        println(\"Failed to find a fixed point after $n times iterations. The last point is:\")\n        data[2]\n    end\nend\n\npara = [0.2, pi / 4, 0.98, 2]\nfixedpoint = newton(SA[0.0, 0.0], para)\nunstable_direction = eigen(jac(fixedpoint, para)).vectors[:, 2]\nseg = segment(fixedpoint, unstable_direction, 150, 0.01)\nresult = generate_curves(setup, para, seg, 0.001, 11)\n\nfunction manifold_plot(result)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(result)\n        for j in eachindex(result[k])\n            data=result[k][j].pcurve.u\n            lines!(axes,first.(data),last.(data))\n        end\n    end\n    fig\nend\n\nmanifold_plot(result)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"<img src=\"../figs/impact.png\" width=\"600\"/>","category":"page"},{"location":"examples.html#Unstable-manifold-of-the-Filippov-system's-time-T-map","page":"Examples","title":"Unstable manifold of the Filippov system's time-T-map","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"I don't found any existing simple examples, but I think the codes should just work.","category":"page"},{"location":"index.html#InvariantManifolds.jl","page":"Home","title":"InvariantManifolds.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The purpose of this package is to provide a convenience tool to numerically investigate the low dimensional invariant manifolds. We don't provide any numerical stability or reliable commitment. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The main idea of this package is quite simple. By using the local manifolds of saddles, extend this manifolds step by step. We just keep the points near enough (with the distance and curvature control) to ensure the accuracy of the numerical manifolds.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The two-dimensional algorithm for smooth mapping of this package is based on the one-dimensional algorithm. The numerical manifolds are represented as plenty near enough circles.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The most interesting part of this package is the computing of the non-smooth invariant manifolds in a reliable way. See the examples for more details.","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"using InvariantManifolds, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"smooth_one.html#开始使用:-一维光滑流形","page":"Get started: Smooth one-dimensional manifolds","title":"开始使用: 一维光滑流形","text":"","category":"section"},{"location":"smooth_one.html#非线性映射","page":"Get started: Smooth one-dimensional manifolds","title":"非线性映射","text":"","category":"section"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"考虑如下的 Henon 映射:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"beginaligned\nx=1-alpha x^2+y\ny=beta x\nendaligned","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"其中 alphabeta 为参数. 这个映射具有不动点:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"beginaligned\n(x_1y_1)=(frac-sqrt4 alpha +beta ^2-2 beta +1+beta -12 alpha frac12 left(fracbeta ^2alpha -fracbeta  sqrt4 alpha +beta ^2-2 beta +1alpha -fracbeta alpha right))\n(x_2y_2)=(fracsqrt4 alpha +beta ^2-2 beta +1+beta -12 alpha frac12 left(fracbeta ^2alpha +fracbeta  sqrt4 alpha +beta ^2-2 beta +1alpha -fracbeta alpha right))\nendaligned","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"下面我们计算在经典参数 alpha=14beta=03 下这两个不动点的特征值:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"using StaticArrays, LinearAlgebra\nfunction fixedpoints(p)\n    a , b = p\n    x1 = (-sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)\n    y1 = (1 / 2) * (b^2 / a - b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)\n    x2 = (sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)\n    y2 = (1 / 2) * (b^2 / a + b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)\n    return SA[x1, y1], SA[x2, y2]\nend\n\nfunction jacobian(x, p)\n    a, b = p\n    J = @SMatrix [-2 * a * x[1] 1.0; b 0.0]\n    return J\nend","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"eigen(jacobian(fixedpoints([1.4, 0.3])[1], [1.4, 0.3]))","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3]))","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"可以看到, 在经典参数下, 这两个不动点均是不稳定的. 下面我们考虑使用 InvariantManifolds.jl 这个软件包来计算第二个不动点的不稳定流形分支的一支. ","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"InvariantManifolds.jl 这个软件包具有类似于很多 Julia 软件包的接口. 首先, 我们需要在 Julia 中加载这个包, 然后定义 Henon 映射:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"using InvariantManifolds\nfunction henonmap(x, p)\n    y1 = 1 - p[1] * x[1]^2 + x[2]\n    y2 = p[2] * x[1]\n    SA[y1, y2]\nend","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"由于这个映射在鞍点处的不稳定特征值为:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3])).values[1]","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"我们需要对这个映射进行两次迭代, 保证延拓时流形不会反向:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"henonmap2(x, p)=henonmap(henonmap(x, p), p)","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"下面我们定义一个计算光滑映射的一维流形的问题:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"para = [1.4, 0.3]\nprob = OneDManifoldProblem(henonmap2, para)","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"为了计算流形, 我们需要一段起点在鞍点的一小段局部流形. 通常起点在鞍点, 长度非常小的不稳定特征矢量即可满足要求. InvariantManifolds.jl 提供了一个函数 gen_segment 来生成这样的局部流形:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"saddle = fixedpoints(para)[2]\nunstable_direction = eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3])).vectors[:,1]\nsegment = gen_segment(saddle, unstable_direction)","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"在默认的关键字参数下, 这个函数会生成一个起点在鞍点, 长度为 150 个单位, 步长为 001 的局部流形. 下面我们使用这个局部流形来计算光滑流形:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"manifold = growmanifold(prob, segment, 8)","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"这个软件包不提供绘图功能. 但是由于流形的计算结果保存在 manifold.data 中, 而 manifold.data 实际上是一个向量, 其元素是软件包 DataInterpolations.jl 中的插值函数:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"manifold.data","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"因此, 我们可以定义如下函数来绘制光滑流形:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"using CairoMakie\nfunction manifold_plot(data)\n    figure = Figure()\n    axes = Axis(figure[1,1])\n    for k in eachindex(data)\n        points = data[k].u\n        lines!(axes, first.(points), last.(points))\n    end\n    figure\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_one.html#受到周期激励扰动的振子","page":"Get started: Smooth one-dimensional manifolds","title":"受到周期激励扰动的振子","text":"","category":"section"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"下面我们考虑一个更高阶的例子. 考虑如下的受到周期激励扰动的振子:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"beginaligned\ndotx=y\ndoty=x-delta x^3+gamma cos(omega t)\nendaligned","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"当 gamma=0 时, 系统在 (00) 处有一个鞍点. 在小的周期扰动之后, 这个鞍点变成了一个鞍周期轨道, 即映射 TXmapsto phi(X2pi0) 的鞍点, 其中 phi(Xtt_0) 是系统在初始条件 X(t_0)=XinmathbbR^2 下的解. 幸运的是, 我们可以利用变分方程的解来获得映射 T 的雅可比矩阵. 映射 T 的鞍点位置和不稳定方向也可以通过数值方法获得.","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"InvariantManifolds.jl 提供了一个函数 findsaddle 来获得 T 的鞍点位置和不稳定方向. 下面我们给出代码以示意如何使用这个函数:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nf(x, p, t) = SA[x[2], x[1] - p[1]*(x[1]^3) + p[2]*cos(p[3]*t)]\ndf(x, p, t) = SA[0.0 1.0; 1-p[1]*3*(x[1]^2) 0.0]\ninitial_guess = SA[0.0, 0.0]\npara = [1.0, 0.1, 2.2]\ntimespan = (0.0, 2pi/para[3])\nsaddle = findsaddle(f, df, timespan, initial_guess, para)","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"函数 gen_segment 可以直接作用于结构体 Saddle. 因此我们可以使用如下代码来生成一个局部流形:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"segment = gen_segment(saddle)","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"现在我们可以定义非线性映射:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"function timeTmap(x, p)\n    prob = ODEProblem{false}(f, x, (0.0, 2pi/p[3]), p)\n    solve(prob, Vern9(), abstol=1e-10)[end]\nend","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"接着创建问题, 求解:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"prob = OneDManifoldProblem(timeTmap, para)\nmanifold = growmanifold(prob, segment, 7)","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"最后再利用上一小节定义的函数来绘制结果:","category":"page"},{"location":"smooth_one.html","page":"Get started: Smooth one-dimensional manifolds","title":"Get started: Smooth one-dimensional manifolds","text":"manifold_plot(manifold.data)","category":"page"},{"location":"smooth_two.html#Smooth-two-dimensional-manifolds","page":"Smooth two-dimensional manifolds","title":"Smooth two-dimensional manifolds","text":"","category":"section"},{"location":"smooth_two.html#Autonomous-vector-field-example","page":"Smooth two-dimensional manifolds","title":"Autonomous vector field example","text":"","category":"section"},{"location":"smooth_two.html#Nonlinear-map-example","page":"Smooth two-dimensional manifolds","title":"Nonlinear map example","text":"","category":"section"}]
}

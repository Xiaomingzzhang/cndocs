var documenterSearchIndex = {"docs":
[{"location":"non_smooth_one.html#非光滑一维流形","page":"非光滑一维流形","title":"非光滑一维流形","text":"","category":"section"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"或许这个软件包最值得注意的地方就是其可以计算非光滑流形. 目前, 支持两类系统的非光滑流形计算:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"时间周期的非光滑微分方程的一维流形计算\n非光滑自治系统的二维流形计算","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"其中流形值得都是鞍点的不变流形, 前者需要取时间周期映射, 后者则需要取固定步长的时间-T-映射. 这两类系统中的非光滑因素可以是多种多样的, 包括分段光滑, 碰撞, 以及它们之间的组合. 这三类非光滑系统无需用户自己求解, 我们提供了三个封装的结构体:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"PiecewiseV\nBilliardV\nPiecewiseImpactV","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"并使用 OrdinaryDiffEq.jl 中的 Callback 功能来进行时间映射的计算. 下面将以三个例子来介绍这三类非光滑系统不变流形的计算方法.","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"warning: Warning\n关于非光滑流形的计算严重依赖于求解 ODE 的算法与精度, 当求解失败或效果不佳时, 可以尝试更换算法, 提高求解 ODE 的精度, 或者降低 NSOneDManifoldProblem 中的参数 ϵ, d, amax 的值的大小.","category":"page"},{"location":"non_smooth_one.html#分段光滑系统","page":"非光滑一维流形","title":"分段光滑系统","text":"","category":"section"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"考虑一个简单的分段光滑系统:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"beginaligned\ndotx=y\ndoty=f(x) + epsilon sin(2pi t)\nendaligned","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"其中","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"f(x) =\nbegincases\n-k_1 x textif  x  -d\nk_2 x  textif  -dxd\n-k_3 x textif  x  d\nendcases","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"k_1k_2k_3d0","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"都为正的常数. 下面我们将计算时间周期映射的不变流形. 注意到当周期扰动很小时, 鞍点应当很接近原点.","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"首先加载用到的程序包","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"接着定义分段光滑的矢量场:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"f1(x, p, t) = SA[x[2], p[1]*x[1]+p[4]*sin(2pi * t)]\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[4]*sin(2pi * t)]\nf3(x, p, t) = SA[x[2], -p[3]*x[1]+p[4]*sin(2pi * t)]\n\nhyper1(x, p, t) = x[1] - p[5]\nhyper2(x, p, t) = x[1] + p[5]\n\ndom1(x, p, t) = -p[5] < x[1] < p[5]\ndom2(x, p, t) = x[1] > p[5]\ndom3(x, p, t) = x[1] < -p[5]\n\nvectorfield = PiecewiseV((f1, f2, f3), (dom1, dom2, dom3), (hyper1, hyper2))","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"传递给 PiecewiseV 这个结构体的参数分别为: 矢量场, 它们所在的区域, 以及分割这些区域的超平面. 更多细节可参考 PiecewiseV.","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"接下来我们将求解时间周期映射的关键信息封装到另外一个结构体 NSSetUp 中:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"setup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"其中函数 setmap 用于封装时间映射的计算信息. 现在我们已经定义好求解时间周期映射的一切了.","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"接下来为了生成局部流形. 我们同样需要定位鞍点以及其不稳定特征向量. 取定参数:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"para = para = [2, 5, 5, 0.6, 2]","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"由于扰动是很小的, 鞍型的周期轨道应该仍然在 dom1 中. 因此我们可以使用 findsaddle 来计算鞍点的位置:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"function df1(x, p, t)\n    SA[0 1; p[1] 0]\nend\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"接下来创建问题, 生成局部流形, 并进行延拓","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"prob = NSOneDManifoldProblem(setup, para, ϵ = 1e-3)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 8)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"注意到, manifold.data 的数据类型是 Vector{Vector{S}}, 其中 S 是插值函数. 所以绘制结果需要使用如下函数:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"完整代码:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nf1(x, p, t) = SA[x[2], p[1]*x[1]+p[4]*sin(2pi * t)]\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[4]*sin(2pi * t)]\nf3(x, p, t) = SA[x[2], -p[3]*x[1]+p[4]*sin(2pi * t)]\nhyper1(x, p, t) = x[1] - p[5]\nhyper2(x, p, t) = x[1] + p[5]\ndom1(x, p, t) = -p[5] < x[1] < p[5]\ndom2(x, p, t) = x[1] > p[5]\ndom3(x, p, t) = x[1] < -p[5]\nvectorfield = PiecewiseV((f1, f2, f3), (dom1, dom2, dom3), (hyper1, hyper2))\nsetup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8)\npara = [2, 5, 5, 0.6, 2]\nfunction df1(x, p, t)\n    SA[0 1; p[1] 0]\nend\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)\nprob = NSOneDManifoldProblem(setup, para, ϵ = 1e-3)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 8)\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one.html#碰撞系统","page":"非光滑一维流形","title":"碰撞系统","text":"","category":"section"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"考虑如下的受到激励的倒摆方程:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"beginaligned\ndotx= y\ndoty= sin(x) - epsilon cos(2pi t)\nendaligned","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"假设倒摆两边存在墙壁: 当 x=xi 或者 x=-xi 时, 有 yrightarrow - ry. 同样地, 需要先构建非光滑矢量场","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"f(x, p, t) = SA[x[2], sin(x[1])-p[1]*cos(2 * pi * t)]\n\nhyper1(x, p, t) = x[1] + p[2]\nhyper2(x, p, t) = x[1] - p[2]\n\nrule1(x, p, t) = SA[x[1], -p[3]*x[2]]\nrule2(x, p, t) = SA[x[1], -p[3]*x[2]]\n\nvectorfield = BilliardV(f, (hyper1, hyper2), (rule1, rule2))","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"接着封装求解时间周期映射的信息:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"setup = setmap(vectorfield, (0.0, 1.0), Vern9(), abstol=1e-10)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"寻找鞍点:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"function df(x, p, t)\n    SA[0 1; cos(x[1]) 0]\nend\npara = [0.2, pi / 4, 0.98]\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f, df, (0.0,1.0), initialguess, para, abstol=1e-10)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"接下来创建问题, 生成局部流形, 并进行延拓","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"prob = NSOneDManifoldProblem(setup, para)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 11)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"最后绘制结果: ","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"manifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"完整代码:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nf(x, p, t) = SA[x[2], sin(x[1])-p[1]*cos(2 * pi * t)]\nhyper1(x, p, t) = x[1] + p[2]\nhyper2(x, p, t) = x[1] - p[2]\nrule1(x, p, t) = SA[x[1], -p[3]*x[2]]\nrule2(x, p, t) = SA[x[1], -p[3]*x[2]]\nvectorfield = BilliardV(f, (hyper1, hyper2), (rule1, rule2))\nsetup = setmap(vectorfield, (0.0, 1.0), Vern9(), abstol=1e-10)\nfunction df(x, p, t)\n    SA[0 1; cos(x[1]) 0]\nend\npara = [0.2, pi / 4, 0.98]\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f, df, (0.0,1.0), initialguess, para, abstol=1e-10)\nprob = NSOneDManifoldProblem(setup, para)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 11)\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one.html#分段光滑与碰撞的组合的-ODE-系统","page":"非光滑一维流形","title":"分段光滑与碰撞的组合的 ODE 系统","text":"","category":"section"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"现在考虑同时存在分段光滑与碰撞的 ODE 系统:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"beginaligned\ndotx=y\ndoty=f(x) + epsilon sin(2pi t)\nendaligned","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"其中","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"f(x) =\nbegincases\n-k_1 x textif  x  -d\nk_2 x  textif  -dxd\nendcases","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"k_1k_2d0","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"都为正的常数. 当 x=d 时, 有 doty--rdoty. 下面我们将计算时间周期映射的不变流形. 注意到当周期扰动很小时, 鞍点应当很接近原点. 首先加载用到的程序包","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"接着定义非光滑矢量场:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"f1(x, p, t) = SA[x[2], p[1]*x[1]+p[3]*sin(2pi * t)]\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[3]*sin(2pi * t)]\n\nhyper1(x, p, t) = x[1] - p[4]\nhyper2(x, p, t) = x[1] + p[4]\n\ndom1(x, p, t) = -p[4] < x[1]\ndom2(x, p, t) = x[1] < -p[4]\n\nimpact_rule(x, p, t) = SA[x[1], -p[5]*x[2]]\nid(x,p,t) = x\n\nvectorfield = PiecewiseImpactV((f1, f2), (dom1, dom2), (hyper1, hyper2), (impact_rule, id), [1])","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"传递给 PiecewiseImpactV 这个结构体的参数分别为: 矢量场, 它们所在的区域, 以及分割这些区域的超平面, 作用在超平面上的规则, 以及具有碰撞效应的那些规则列表. 更多细节可参考 PiecewiseImpactV.","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"接下来我们将求解时间周期映射的关键信息封装到另外一个结构体 NSSetUp 中:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"setup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8, reltol=1e-8)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"其中函数 setmap 用于封装时间映射的计算信息. 现在我们已经定义好求解时间周期映射的一切了.","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"接下来为了生成局部流形. 我们同样需要定位鞍点以及其不稳定特征向量. 取定参数:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"para = [2, 5, 0.5, 2, 0.98]","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"由于扰动是很小的, 鞍型的周期轨道应该仍然在 dom1 中. 因此我们可以使用 findsaddle 来计算鞍点的位置:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"function df1(x, p, t)\n    SA[0 1; p[1] 0]\nend\ninitialguess = SA[0.0, 0.0]\nsaddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"接下来创建问题, 生成局部流形, 并进行延拓","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"prob = NSOneDManifoldProblem(setup, para)\nsegment = gen_segment(saddle)\nmanifold = growmanifold(prob, segment, 9)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"注意到, manifold.data 的数据类型是 Vector{Vector{S}}, 其中 S 是插值函数. 所以绘制结果需要使用如下函数:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using CairoMakie\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"完整代码:","category":"page"},{"location":"non_smooth_one.html","page":"非光滑一维流形","title":"非光滑一维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nf1(x, p, t) = SA[x[2], p[1]*x[1]+p[3]*sin(2pi * t)]\nf2(x, p, t) = SA[x[2], -p[2]*x[1]+p[3]*sin(2pi * t)]\nhyper1(x, p, t) = x[1] - p[4]\nhyper2(x, p, t) = x[1] + p[4]\ndom1(x, p, t) = -p[4] < x[1]\ndom2(x, p, t) = x[1] < -p[4]\nimpact_rule(x, p, t) = SA[x[1], -p[5]*x[2]]\nid(x,p,t) = x\nvectorfield = PiecewiseImpactV((f1, f2), (dom1, dom2), (hyper1, hyper2), (impact_rule, id), [1])\nsetup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8, reltol=1e-8)\npara = [2, 5, 0.5, 2, 0.98]\ninitialguess = SA[0.0, 0.0]\nfunction df1(x, p, t)\n    SA[0 1; p[1] 0]\nend\nsaddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)\nsegment = gen_segment(saddle)\nprob = NSOneDManifoldProblem(setup, para)\nmanifold = growmanifold(prob, segment, 9)\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis(fig[1,1])\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            lines!(axes,first.(points),last.(points))\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"api.html#API","page":"类型与函数","title":"API","text":"","category":"section"},{"location":"api.html","page":"类型与函数","title":"类型与函数","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html","page":"类型与函数","title":"类型与函数","text":"Modules = [InvariantManifolds]\nOrder   = [:type, :function]","category":"page"},{"location":"api.html#InvariantManifolds.BilliardV","page":"类型与函数","title":"InvariantManifolds.BilliardV","text":"BilliardV\n\nA callable struct to represent a vector field with multiple hyper surfaces such that the flow jump when hits these hyper surfaces.\n\nFields\n\nf is the vector field, of type f(x,p,t), and its output is a SVector;\nhypers is tuple of hyper surfaces:(h1,h2,...), h1(x,p,t);\nrules is tuple of rules on hyper surfaces:(r1,r2,r3,...).\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.FlawPoint","page":"类型与函数","title":"InvariantManifolds.FlawPoint","text":"FlawPoint{N,T}\n\nFlawPoint is a struct to record the points that don't satisfy the angle and distance request while the  program has reached the minimum arc length.\n\nFields\n\npoint flaw point in the process of continuation;\nα the angle recorded;\nd the distance recorded.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSOneDManifold","page":"类型与函数","title":"InvariantManifolds.NSOneDManifold","text":"NSOneDManifold{F,S,N,T}\n\nNSOneDManifold is a struct contains all the information of the non-smooth one-dimensional numerical manifold.\n\nFields\n\nprob the problem NSOneDManifoldProblem;\ndata the numerical data that should be Vector{Vector{Vector{S}}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSOneDManifoldProblem","page":"类型与函数","title":"InvariantManifolds.NSOneDManifoldProblem","text":"NSOneDManifoldProblem{F,T}\n\nNSOneDManifoldProblem is a struct to contain the main information for continuing the non-smooth one-dimensional manifold of the time-T-map of a non-smooth ODE.\n\nFields\n\nf the struct NSSetUp;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\nϵ the max value of the following expression: maxH(x_0T)H(x_1T) where H(xt) is the hypersurface the manifold cross, x_0 and x_1 are points before and after the cross, T is the end of the time-T-map (from 0 to T).\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are NSOneDManifoldProblem(f) and NSOneDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSSetUp","page":"类型与函数","title":"InvariantManifolds.NSSetUp","text":"NSSetUp{T}\n\nNSSetUp is a struct to contain all the information needed in continuing the manifold of non-smooth ODE.\n\nFields\n\nf the Non-smooth vector field, like PiecewiseV;\ntimespan the time span of time-T-map;\ntimetmap the time-t-map of non-smooth ODE, which maps a NSState and parameters of ODE to a NSState.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSSolution","page":"类型与函数","title":"InvariantManifolds.NSSolution","text":"NSSolution{N,T<:Number}\n\nThe NSSolution is a struct to contain all information of the solution of a non-smooth ODE system.\n\nFields\n\nsol ODESolution solved by OrdinaryDiffEq;\nevent_t the times when events happen;\nevent_state the solution's state when events happen;\nevent_at is a vector that contains integers indicating which event happen.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSState","page":"类型与函数","title":"InvariantManifolds.NSState","text":"NSState{N,T<:Number} <: AbstractVector{T}\n\nThe struct NSState is to record the events data for a time-T-map.\n\nFields\n\nstate the final state of the time-T-map;\nevent_at is a integer vector that contains the history of the events happened.\n\nThe construction of NSState allows to interpolate vectors consisting of NSState. Currently, LinearInterpolation, CubicSpline, and QuadraticInterpolation in DataInterpolations.jl are supported.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSVTwoDManifold","page":"类型与函数","title":"InvariantManifolds.NSVTwoDManifold","text":"NSVTwoDManifold{F,S,N,T}\n\nNSVTwoDManifold is a struct contains all the information of the non-smooth two-dimensional numerical manifold of an autonomous vector field.\n\nFields\n\nprob the problem NSVTwoDManifoldProblem;\ndata the numerical data that should be Vector{Vector{S}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.NSVTwoDManifoldProblem","page":"类型与函数","title":"InvariantManifolds.NSVTwoDManifoldProblem","text":"NSVTwoDManifoldProblem{F,T}\n\nNSVTwoDManifoldProblemVTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of an autonomous vector field.\n\nFields\n\nf the NSSetUp of a nonsmooth vector field;\npara the parameters of the time flow map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\nϵ the max value of the following expression: maxH(x_0T)H(x_1T) where H(xt) is the hypersurface of the manifold cross, x_0 and x_1 are points before and after the cross, T is the end of the time-T-map (from 0 to T).\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are NSVTwoDManifoldProblem(f) and NSVTwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.ODESolver","page":"类型与函数","title":"InvariantManifolds.ODESolver","text":"ODESolver{F1,F2,T}\n\nA wrapper struct for solving ordinary differential equations (ODEs).\n\nFields\n\nf: Vector field function of the ODE system in the form f(x,p,t)\ntimespan: Time interval for solving the ODE, of type Tuple{T,T}\nalg: The numerical algorithm used for solving the ODE\nabstol: Absolute tolerance for the numerical solver\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.OneDManifold","page":"类型与函数","title":"InvariantManifolds.OneDManifold","text":"OneDManifold{F,S,N,T}\n\nOneDManifold is a struct contains all the information of the one-dimensional numerical manifold.\n\nFields\n\nprob the problem OneDManifoldProblem;\ndata the numerical data that should be Vector{Vector{S}}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.OneDManifoldProblem","page":"类型与函数","title":"InvariantManifolds.OneDManifoldProblem","text":"OneDManifoldProblem{F,T}\n\nOneDManifoldProblem is a struct to contain the main information for continuing the one-dimensional manifold of a nonlinear map.\n\nFields\n\nf the nonlinear map, which should has the form f(x,p) and return a SVector;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are OneDManifoldProblem(f) and OneDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.PiecewiseImpactV","page":"类型与函数","title":"InvariantManifolds.PiecewiseImpactV","text":"PiecewiseImpactV\n\nA callable struct to represent a vector field with both piecewise non-smoothness and impacts.\n\nfs is a tuple of smooth vector fields in different regions.\nregions is a tuple of the region functions: (r1,r2,...), where r1(x,p,t) should return a Bool value to indicate that x is in this region or not.\nhypers is a tuple of the hyper surfaces separating the regions.\nrules is a tuple of rules on hyper surfaces:(r1,r2,r3,...). Note that for hypersurfaces that only switch between two vector fields, we can set r1=id.\nidxs is a vector of integer to indicate hypersurfaces with impact effects.\nn is a integer to switch between vector fields. Default to be zero.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.PiecewiseV","page":"类型与函数","title":"InvariantManifolds.PiecewiseV","text":"PiecewiseV\n\nA callable struct to represent a piecewise smooth vector field. \n\nFields\n\nfs is a tuple of smooth vector fields in different regions.\nregions is a tuple of the region functions: (r1,r2,...), where r1(x,p,t) should return a Bool value to indicate that x is in this region or not.\nhypers is a tuple of the hyper surfaces separating the regions.\nn is a integer to switch between vector fields. Default to be zero.\n\nExample\n\nusing StaticArrays, InvariantManifolds\nf1(x,p,t)=SA[x[2],-2x[1]]\nf2(x,p,t)=SA[x[2],-x[1]]\ndom1(x,p,t)=x[1]>0\ndom2(x,p,t)=x[2]<0\nhyper(x,p,t)=x[1]\nPiecewiseV((f1,f2),(dom1,dom2),(hyper,))\n\nThe above codes generate a piecewise smooth vector field, which when x[1]>0 is f1, and when x[2]<0 is f2. The hyper surface separating these smooth vector fields is x[1]=0.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.Saddle","page":"类型与函数","title":"InvariantManifolds.Saddle","text":"Saddle{N,T,S}\n\nSaddle is a struct to contain the information of a saddle point needed in continuing the manifold of non-smooth ODE. For an ODE's saddle, this struct can be constructed by the function findsaddle.\n\nFields\n\nsaddle the location of the saddle point;\nunstable_directions the unstable directions;\nunstable_eigen_values eigenvalues of the linearized map in the saddle at the unstable eigenvectors.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.TwoDManifold","page":"类型与函数","title":"InvariantManifolds.TwoDManifold","text":"TwoDManifold{F,S,N,T}\n\nTwoDManifold is a struct contains all the information of the two-dimensional numerical manifold of a nonlinear map.\n\nFields\n\nprob the problem TwoDManifoldProblem;\ndata the numerical data that should be Vector{S}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.TwoDManifoldProblem","page":"类型与函数","title":"InvariantManifolds.TwoDManifoldProblem","text":"TwoDManifoldProblem{F,T}\n\nTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of a nonlinear map.\n\nFields\n\nf the nonlinear map, which should has the form f(x,p) and return a SVector;\npara the parameters of the nonlinear map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndcircle the maximum distance between circles when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are TwoDManifoldProblem(f) and TwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.VTwoDManifold","page":"类型与函数","title":"InvariantManifolds.VTwoDManifold","text":"VTwoDManifold{F,S,N,T}\n\nVTwoDManifold is a struct contains all the information of the two-dimensional numerical manifold of an autonomous vector field.\n\nFields\n\nprob the problem VTwoDManifoldProblem;\ndata the numerical data that should be Vector{S}, where S is the interpolation curve (we use DataInterpolation in this package);\nflawpoints the flaw points generated during continuation.\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.VTwoDManifoldProblem","page":"类型与函数","title":"InvariantManifolds.VTwoDManifoldProblem","text":"VTwoDManifoldProblem{F,T}\n\nVTwoDManifoldProblem is a struct to contain the main information for continuing the two-dimensional manifold of an autonomous vector field.\n\nFields\n\nf the time flow map of the vector field, which should has the form f(x,p) and return a SVector; note that the vector field should be regularized, e.g., dotx=v(x) should be rewritten as dotx=v(x)sqrt1+v(x);\npara the parameters of the time flow map;\namax the maximum angle between points when continuing the manifold;\nd the maximum distance between points when continuing the manifold;\ndsmin the minimum arc length allowing; note that if in a continuation point, this value is achieved and the angle as well as the distance values are not achieved, then we will record this point as a FlawPoint.\n\nConvenient consturctors are VTwoDManifoldProblem(f) and VTwoDManifoldProblem(f,para)\n\n\n\n\n\n","category":"type"},{"location":"api.html#InvariantManifolds.addcircles!-NTuple{8, Any}","page":"类型与函数","title":"InvariantManifolds.addcircles!","text":"InvariantManifolds.addcircles!(f, para, d, circles, dsmin, αmax, dcircle, flawpoints; interp=LinearInterpolation)\n\nAdds and refines circles in the two-dimensional manifold computation by iterating the map and ensuring proper point distribution.\n\nArguments\n\nf: The nonlinear map function\npara: Vector of parameters for the map\nd: Maximum allowed distance between points in a circle\ncircles: Vector of interpolated curves representing the current circles\ndsmin: Minimum allowed arc length between points\nαmax: Maximum allowed angle between consecutive points\ndcircle: Maximum allowed distance between consecutive circles\nflawpoints: Vector to store problematic points during computation\ninterp: Interpolation method (default: QuadraticInterpolation)\n\nReturns\n\nA vector of new interpolated curves representing the refined circles after one iteration of the map.\n\nDetails\n\nThe function performs two main steps:\n\nIterates each circle forward under the map and refines point distribution within each circle\nAdds intermediate circles where the distance between consecutive circles exceeds dcircle\n\nPoints are added to maintain proper spacing and curvature constraints specified by d and αmax.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Array{StaticArraysCore.SVector{N, T}, 1}, Vector{T}, Any, Any, Any}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.addpoints!","text":"InvariantManifolds.addpoints!(f, p, d, oldcurve, newu, olds, dsmin, αmax, flawpoints)\n\nAdd points to ensure proper spacing and curvature along a one-dimensional manifold curve.\n\nArguments\n\nf: The nonlinear map function\np: Parameters for the nonlinear map\nd: Maximum allowed distance between consecutive points\noldcurve: Previous curve interpolation\nnewu::Vector{SVector{N,T}}: New points to be processed\nolds::Vector{T}: Parameter values of the points\ndsmin: Minimum allowed arc length between points\nαmax: Maximum allowed angle between consecutive segments\nflawpoints: Vector to store problematic points that don't meet criteria\n\nDetails\n\nThe function iteratively processes points, adding new ones when:\n\nThe distance between consecutive points exceeds d\nThe angle between consecutive segments exceeds αmax\nThe arc length is greater than dsmin\n\nIf a point fails these criteria and the minimum arc length is reached, it's recorded as a flaw point.\n\nReturns\n\nVector of parameter values for the new points\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.findsaddle-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, StaticArraysCore.SVector{N, T}, Any}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.findsaddle","text":"findsaddle(v, dv, timespan, x, p)\n\nfindsaddle is a function to find the saddle of the time-T-map of smooth ODE systems, by using the Newton's method.\n\nParameters\n\nv the vector field, which should be the form f(x,p,t) and return a SVector;\ndv the Jacobi matrix function of v, which should should be the form dv(x,p,t) and return a SMatrix;\ntimespan the time span of the time-T-map;\nx the initial point to iterate.\n\nKeyword arguments\n\nn maximum iterate times, default to be 100;\nabstol absolute tolerance for the fixed point, default to be 1e-8;\nalg the algorithm used to solve the ODE, default to be Vern9().\n\nReturns\n\nA Saddle object, which contains the fixed point and the directions of the stable manifold.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.gen_disk-Union{Tuple{Saddle{N, T, S}}, Tuple{S}, Tuple{T}, Tuple{N}} where {N, T, S}","page":"类型与函数","title":"InvariantManifolds.gen_disk","text":"gen_disk(p, times)\n\ngen_disk is a function to generate circles around the saddle, which represented as the local manifold.\n\nParameters\n\np the struct Saddle which should contains two unstable directions; the complex eigenvalues and eigenvectors are allowed.\n\nKeyword arguments\n\ntimes the iteration time, default to be 1; for the computation of invariant manifolds of nonlinear map, this parameter is needed to adjust the torsion in different directions in the process of continuation.\nn the number of point in each circle, default to be 150;\nd the max distance between points in a single circle, default to be 0.0002;\nr the size of the disk, default to be 0.05;\ncircles the number of the circles, default to be 10.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.gen_segment-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Any}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.gen_segment","text":"gen_segment(saddle, direction)\n\nGenerating n points at saddle in the direction, with length d, with default n=50 and d=0.01. Another Convenient consturctor is gen_segment(p::Saddle).\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.grow!-Tuple{InvariantManifolds.OneDManifold}","page":"类型与函数","title":"InvariantManifolds.grow!","text":"grow!(manifold)\n\nOne time iteration to grow the manifold.\n\nParameters\n\nmanifold the manifold struct.\n\nKeyword argument\n\ninterp the interpolation method used, default to be QuadraticInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.growmanifold-Tuple{OneDManifoldProblem, Any, Any}","page":"类型与函数","title":"InvariantManifolds.growmanifold","text":"growmanifold(prob, points, N)\n\nThis is the mani function to continuate the numerical manifolds. Its output is a manifold struct.\n\nParameters\n\nprob the problem such as OneDManifoldProblem.\npoints the points in the local manifold. For one dimensional manifolds, these points should be a Vector{SVector} and the start point should be the saddle. For two dimensional manifolds, these points should be a Vector{Vector{S}} and its first element should like [saddle, saddle, saddle]. Note that in the both cases, the functions gen_segment and gen_disk can generate these points easily.\nN the number of iterations.\n\nKeyword argument\n\ninterp the interpolation method used, default to be QuadraticInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.initialize-Union{Tuple{T}, Tuple{N}, Tuple{OneDManifoldProblem, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.initialize","text":"initialize(prob, points)\n\nThis is a function to initialize the continuation process. Its output is a manifold struct.\n\nParameters\n\nprob the problem such as OneDManifoldProblem.\npoints the points in the local manifold. For one dimensional manifolds, these points should be a Vector{SVector} and the start point should be the saddle. For two dimensional manifolds, these points should be a Vector{Vector{S}} and its first element should like [saddle, saddle, saddle]. Note that in the both cases, the functions gen_segment and gen_disk can generate these points easily.\n\nKeyword argument\n\ninterp the interpolation method used, default to be QuadraticInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.iscontact-Union{Tuple{S}, Tuple{T}, Tuple{N}, Tuple{Any, Saddle{N, T, S}, Any}} where {N, T, S}","page":"类型与函数","title":"InvariantManifolds.iscontact","text":"iscontact(setup, saddle, para)\n\nCheck if the saddle point of the time-T-map has contacts with the hypersurfaces.\n\nParameters\n\nsetup a NSSetUp.\nsaddle a Saddle or a SVector.\npara the parameter of the vector field.\n\nReturns\n\ntrue if the saddle point has contact with the hypersurfaces.\nfalse if the saddle point has no contact with the hypersurfaces.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.kd_distence-Union{Tuple{T}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, T}, Array{StaticArraysCore.SVector{N, T}, 1}}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.kd_distence","text":"InvariantManifolds.kd_distence\n\nThe function to measure the distance between two circles by using the package NearestNeighbors.jl.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.ns_addpoints!-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Any, Any, Any, Array{NSState{N, T}, 1}, Vector{T}, Vararg{Any, 5}}} where {N, T}","page":"类型与函数","title":"InvariantManifolds.ns_addpoints!","text":"InvariantManifolds.ns_addpoints!(tmap, p, d, dsmin, oldcurve, newu, olds, αmax, tend, hypers, ϵ, flawpoints) -> Vector{T}\n\nAdd points to ensure proper spacing and accuracy when computing the non-smooth one-dimensional manifold.\n\nArguments\n\ntmap: Time map function that evolves states forward\np: Vector of parameters\nd: Maximum allowed distance between consecutive points\ndsmin: Minimum allowed arc length between points\noldcurve: Previous curve data used for interpolation\nnewu: Vector of new states to be processed\nolds: Vector of arc length parameters\nαmax: Maximum allowed angle between consecutive segments\ntend: End time of the time map\nhypers: Vector of hypersurface functions\nϵ: Maximum allowed error in hypersurface intersection\nflawpoints: Vector to store problematic points encountered\n\nReturns\n\nVector of arc length parameters for the processed points\n\nDetails\n\nThe function adaptively adds points to maintain:\n\nMaximum distance d between consecutive points\nMaximum angle αmax between segments\nAccuracy ϵ at hypersurface intersections\n\nIf constraints cannot be satisfied within dsmin, points are marked as flaws.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.ns_solver-Tuple{PiecewiseV, Vararg{Any, 4}}","page":"类型与函数","title":"InvariantManifolds.ns_solver","text":"ns_solver(v::T, para, timespan, alg, N, T)\n\nThe function ns_solver is similar to timetmap. The output of this function is a function which maps a SVector to a NSSolution. This NSSolution contain all data of an non-smooth ODE solution.\n\nParameters\n\nv vector fields like PiecewiseV or BilliardV.\npara the parameter of the vector field.\ntimespan the time span of the time-T-map.\nalg algorithm in OrdinaryDiffEq to solve ODE.\nN the dimension of the vector field.\nT number type used in computation.\n\nTo ensure type stable, the numbers in para and timespan should be type of T. The last two parameters have to be specified, since we need to store the event data.\n\nKeyword arguments\n\nFor vector fields PiecewiseV and PiecewiseImpactV, we have two special keyword arguments:\n\ncross_time= 0.01 when the solution sol hits the hypersurface at time t, we need to know which domain it enters. We choose the state sol(t+cross_time) to determine which domain it enters.\nregion_detect=_region_detect the region detect function to determine which domain the state in.\nrepeat_nudge=1//100 this is used to set the next testing point after a previously found zero.\n\nYou can also pass the keywords of solve of OrdinaryDiffEq to this function,  except the callback and saving related keywords.\n\n\n\n\n\n","category":"method"},{"location":"api.html#InvariantManifolds.setmap-Union{Tuple{T}, Tuple{PiecewiseV, Tuple{T, T}, Any}} where T","page":"类型与函数","title":"InvariantManifolds.setmap","text":"setmap(v, timespan::Tuple{T,T}, alg; extra...) where {T}\n\nThe function setmap is to get a NSSetUp.\n\nParameters\n\nv a nonsmooth vector field like PiecewiseV or BilliardV.\ntimespan the time span of the time-T-map.\nalg algorithm in OrdinaryDiffEq to solve ODE.\n\nTo ensure type stable, the numbers in timespan should be type of T.\n\nKeyword arguments\n\nFor vector fields PiecewiseV and PiecewiseImpactV, we have two special keyword arguments:\n\ncross_time= 0.01 when the solution sol hits the hypersurface at time t, we need to know which domain it enters. We choose the state sol(t+cross_time) to determine which domain it enters.\nregion_detect=_region_detect the region detect function to determine which domain the state in.\nrepeat_nudge=1//100 this is used to set the next testing point after a previously found zero.\n\nYou can also pass the keywords of solve of OrdinaryDiffEq to this function,  except the callback and saving related keywords.\n\n\n\n\n\n","category":"method"},{"location":"non_smooth_two.html#非光滑两维流形","page":"非光滑两维流形","title":"非光滑两维流形","text":"","category":"section"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"下面我们将继续以 Lorenz 系统为例, 不同的是我们将对这个系统引入一个人为的非光滑因素. 首先加载需要的包:","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie, DataInterpolations","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie, DataInterpolations","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"接着定义在远离原点时归一化的向量场:","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"function lorenz(x, p, t)\n    σ, ρ, β = p\n    v = SA[σ*(x[2]-x[1]),\n        ρ*x[1]-x[2]-x[1]*x[3],\n        x[1]*x[2]-β*x[3]\n    ]\n    v / sqrt(0.1 + norm(v)^2)\nend","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"与先前的例子不同的是, 我们将引入如下非光滑因素: 当 z=xi 时, (xyz)rightarrow(x-yz).  因此, 我们需要定义一个带有碰撞因素的向量场:","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"hyper(x,p,t) = x[3]-p[4]\nrule(x,p,t) = SA[x[1], -x[2], x[3]]\nvectorfield =BilliardV(lorenz, (hyper,),(rule,))","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"接着如同前面的例子, 我们需要将求解这个微分方程的具体信息封装到 NSSetUp 中, 这需要使用函数 setmap:","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"setup = setmap(vectorfield, (0.0, -1.0), Tsit5(), abstol=1e-8)","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"接着同样需要生成一个局部流形:","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"para = [10.0, 28.0, 8/3, 10.0]\nfunction eigenv(p)\n    σ, ρ, β = p\n    [SA[0.0, 0.0, 1.0], SA[-(-1 + σ + sqrt(1 - 2 * σ + 4 * ρ * σ + σ^2))/(2*ρ), 1, 0]]\nend\nsaddle = Saddle(SA[0, 0, 0.0], eigenv(para), [1.0, 1.0])\ndisk = gen_disk(saddle, r=1.0, d=0.1)","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"接着创建问题:","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"prob = NSVTwoDManifoldProblem(setup, para, amax=0.5, d=0.5, ϵ=0.2, dsmin=1e-3)","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"最后计算流形, 并绘制图像:","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"manifold = growmanifold(prob, disk, 90, interp=LinearInterpolation)\nfunction manifold_plot(annulus)\n    fig = Figure()\n    axes = LScene(fig[1, 1], show_axis=false, scenekw=(backgroundcolor=:white, clear=true))\n    second(x) = x[2]\n    for i in eachindex(annulus)\n        for j in eachindex(annulus[i])\n            points = annulus[i][j].u\n            lines!(axes, first.(points), second.(points), last.(points), fxaa=true)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"完整代码:","category":"page"},{"location":"non_smooth_two.html","page":"非光滑两维流形","title":"非光滑两维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie, DataInterpolations\nfunction lorenz(x, p, t)\n    σ, ρ, β = p\n    v = SA[σ*(x[2]-x[1]),\n        ρ*x[1]-x[2]-x[1]*x[3],\n        x[1]*x[2]-β*x[3]\n    ]\n    v / sqrt(0.1 + norm(v)^2)\nend\nhyper(x,p,t) = x[3]-p[4]\nrule(x,p,t) = SA[x[1], -x[2], x[3]]\nvectorfield =BilliardV(lorenz, (hyper,),(rule,))\nsetup = setmap(vectorfield, (0.0, -1.0), Tsit5(), abstol=1e-8)\npara = [10.0, 28.0, 8/3, 10.0]\nfunction eigenv(p)\n    σ, ρ, β = p\n    [SA[0.0, 0.0, 1.0], SA[-(-1 + σ + sqrt(1 - 2 * σ + 4 * ρ * σ + σ^2))/(2*ρ), 1, 0]]\nend\nsaddle = Saddle(SA[0, 0, 0.0], eigenv(para), [1.0, 1.0])\ndisk = gen_disk(saddle, r=1.0, d=0.1)\nprob = NSVTwoDManifoldProblem(setup, para, amax=0.5, d=0.5, ϵ=0.2, dsmin=1e-3)\nmanifold = growmanifold(prob, disk, 90, interp=LinearInterpolation)\nfunction manifold_plot(annulus)\n    fig = Figure()\n    axes = LScene(fig[1, 1], show_axis=false, scenekw=(backgroundcolor=:white, clear=true))\n    second(x) = x[2]\n    for i in eachindex(annulus)\n        for j in eachindex(annulus[i])\n            points = annulus[i][j].u\n            lines!(axes, first.(points), second.(points), last.(points), fxaa=true)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"index.html#InvariantManifolds.jl","page":"主页","title":"InvariantManifolds.jl","text":"","category":"section"},{"location":"index.html","page":"主页","title":"主页","text":"这个软件包的目的是提供一个便捷工具来数值研究低维不变流形. 我们不提供任何数值稳定性或可靠性保证.","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"这个软件包的主要思想非常简单. 通过使用鞍点的局部流形, 逐步延拓这些流形. 我们只保持点足够接近 (通过距离和曲率控制) 以确保数值流形的精度.","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"这个软件包中光滑映射的二维算法是基于一维算法的. 数值流形表示为大量足够接近的圆.","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"这个软件包最有趣的部分是以可靠的方式计算非光滑不变流形. 更多细节请参见示例.","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"using InvariantManifolds, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"smooth_one.html#开始使用:-一维光滑流形","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"","category":"section"},{"location":"smooth_one.html#非线性映射","page":"开始使用: 一维光滑流形","title":"非线性映射","text":"","category":"section"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"考虑如下的 Henon 映射:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"beginaligned\nx=1-alpha x^2+y\ny=beta x\nendaligned","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"其中 alphabeta 为参数. 这个映射具有不动点:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"beginaligned\n(x_1y_1)=(frac-sqrt4 alpha +beta ^2-2 beta +1+beta -12 alpha frac12 left(fracbeta ^2alpha -fracbeta  sqrt4 alpha +beta ^2-2 beta +1alpha -fracbeta alpha right))\n(x_2y_2)=(fracsqrt4 alpha +beta ^2-2 beta +1+beta -12 alpha frac12 left(fracbeta ^2alpha +fracbeta  sqrt4 alpha +beta ^2-2 beta +1alpha -fracbeta alpha right))\nendaligned","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"下面我们计算在经典参数 alpha=14beta=03 下这两个不动点的特征值:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"using StaticArrays, LinearAlgebra\nfunction fixedpoints(p)\n    a , b = p\n    x1 = (-sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)\n    y1 = (1 / 2) * (b^2 / a - b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)\n    x2 = (sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)\n    y2 = (1 / 2) * (b^2 / a + b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)\n    return SA[x1, y1], SA[x2, y2]\nend\n\nfunction jacobian(x, p)\n    a, b = p\n    J = @SMatrix [-2 * a * x[1] 1.0; b 0.0]\n    return J\nend","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"eigen(jacobian(fixedpoints([1.4, 0.3])[1], [1.4, 0.3]))","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3]))","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"可以看到, 在经典参数下, 这两个不动点均是不稳定的. 下面我们考虑使用 InvariantManifolds.jl 这个软件包来计算第二个不动点的不稳定流形分支的一支. ","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"InvariantManifolds.jl 这个软件包具有类似于很多 Julia 软件包的接口. 首先, 我们需要在 Julia 中加载这个包, 然后定义 Henon 映射:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"using InvariantManifolds\nfunction henonmap(x, p)\n    y1 = 1 - p[1] * x[1]^2 + x[2]\n    y2 = p[2] * x[1]\n    SA[y1, y2]\nend","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"由于这个映射在鞍点处的不稳定特征值为:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3])).values[1]","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"我们需要对这个映射进行两次迭代, 保证延拓时流形不会反向:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"henonmap2(x, p)=henonmap(henonmap(x, p), p)","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"下面我们定义一个计算光滑映射的一维流形的问题:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"para = [1.4, 0.3]\nprob = OneDManifoldProblem(henonmap2, para)","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"为了计算流形, 我们需要一段起点在鞍点的一小段局部流形. 通常起点在鞍点, 长度非常小的不稳定特征矢量即可满足要求. InvariantManifolds.jl 提供了一个函数 gen_segment 来生成这样的局部流形:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"saddle = fixedpoints(para)[2]\nunstable_direction = eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3])).vectors[:,1]\nsegment = gen_segment(saddle, unstable_direction)","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"在默认的关键字参数下, 这个函数会生成一个起点在鞍点, 长度为 150 个单位, 步长为 001 的局部流形. 下面我们使用这个局部流形来计算光滑流形:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"manifold = growmanifold(prob, segment, 8)","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"这个软件包不提供绘图功能. 但是由于流形的计算结果保存在 manifold.data 中, 而 manifold.data 实际上是一个向量, 其元素是软件包 DataInterpolations.jl 中的插值函数:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"manifold.data","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"因此, 我们可以定义如下函数来绘制光滑流形:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"using CairoMakie\nfunction manifold_plot(data)\n    figure = Figure()\n    axes = Axis(figure[1,1])\n    for k in eachindex(data)\n        points = data[k].u\n        lines!(axes, first.(points), last.(points))\n    end\n    figure\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"完整代码:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"using StaticArrays, LinearAlgebra, InvariantManifolds, CairoMakie\nfunction fixedpoints(p)\n    a , b = p\n    x1 = (-sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)\n    y1 = (1 / 2) * (b^2 / a - b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)\n    x2 = (sqrt(4 * a + b^2 - 2 * b + 1) + b - 1) / (2 * a)\n    y2 = (1 / 2) * (b^2 / a + b * sqrt(4 * a + b^2 - 2 * b + 1) / a - b / a)\n    return SA[x1, y1], SA[x2, y2]\nend\nfunction jacobian(x, p)\n    a, b = p\n    J = @SMatrix [-2 * a * x[1] 1.0; b 0.0]\n    return J\nend\nfunction henonmap(x, p)\n    y1 = 1 - p[1] * x[1]^2 + x[2]\n    y2 = p[2] * x[1]\n    SA[y1, y2]\nend\nfunction henonmap2(x, p)\n    henonmap(henonmap(x, p), p)\nend\npara = [1.4, 0.3]\nprob = OneDManifoldProblem(henonmap2, para)\nsaddle = fixedpoints(para)[2]\nunstable_direction = eigen(jacobian(fixedpoints([1.4, 0.3])[2], [1.4, 0.3])).vectors[:,1]\nsegment = gen_segment(saddle, unstable_direction)\nmanifold = growmanifold(prob, segment, 8)\nfunction manifold_plot(data)\n    figure = Figure()\n    axes = Axis(figure[1,1])\n    for k in eachindex(data)\n        points = data[k].u\n        lines!(axes, first.(points), last.(points))\n    end\n    figure\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_one.html#受到周期激励扰动的振子","page":"开始使用: 一维光滑流形","title":"受到周期激励扰动的振子","text":"","category":"section"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"下面我们考虑一个更高阶的例子. 考虑如下的受到周期激励扰动的振子:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"beginaligned\ndotx=y\ndoty=x-delta x^3+gamma cos(omega t)\nendaligned","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"当 gamma=0 时, 系统在 (00) 处有一个鞍点. 在小的周期扰动之后, 这个鞍点变成了一个鞍周期轨道, 即映射 TXmapsto phi(X2piomega0) 的鞍点, 其中 phi(Xtt_0) 是系统在初始条件 X(t_0)=XinmathbbR^2 下的解. 幸运的是, 我们可以利用变分方程的解来获得映射 T 的雅可比矩阵. 映射 T 的鞍点位置和不稳定方向也可以通过数值方法获得.","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"InvariantManifolds.jl 提供了一个函数 findsaddle 来获得 T 的鞍点位置和不稳定方向. 下面我们给出代码以示意如何使用这个函数:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nf(x, p, t) = SA[x[2], x[1] - p[1]*(x[1]^3) + p[2]*cos(p[3]*t)]\ndf(x, p, t) = SA[0.0 1.0; 1-p[1]*3*(x[1]^2) 0.0]\ninitial_guess = SA[0.0, 0.0]\npara = [1.0, 0.1, 2.2]\ntimespan = (0.0, 2pi/para[3])\nsaddle = findsaddle(f, df, timespan, initial_guess, para)","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"函数 gen_segment 可以直接作用于结构体 Saddle. 因此我们可以使用如下代码来生成一个局部流形:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"segment = gen_segment(saddle)","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"现在我们可以定义非线性映射:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"function timeTmap(x, p)\n    prob = ODEProblem{false}(f, x, (0.0, 2pi/p[3]), p)\n    solve(prob, Vern9(), abstol=1e-10)[end]\nend","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"接着创建问题, 求解:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"prob = OneDManifoldProblem(timeTmap, para)\nmanifold = growmanifold(prob, segment, 7)","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"最后再利用上一小节定义的函数来绘制结果:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"manifold_plot(manifold.data)","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"完整代码:","category":"page"},{"location":"smooth_one.html","page":"开始使用: 一维光滑流形","title":"开始使用: 一维光滑流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nf(x, p, t) = SA[x[2], x[1] - p[1]*(x[1]^3) + p[2]*cos(p[3]*t)]\ndf(x, p, t) = SA[0.0 1.0; 1-p[1]*3*(x[1]^2) 0.0]\ninitial_guess = SA[0.0, 0.0]\npara = [1.0, 0.1, 2.2]\ntimespan = (0.0, 2pi/para[3])\nsaddle = findsaddle(f, df, timespan, initial_guess, para)\nsegment = gen_segment(saddle)\nfunction timeTmap(x, p)\n    prob = ODEProblem{false}(f, x, (0.0, 2pi/p[3]), p)\n    solve(prob, Vern9(), abstol=1e-10)[end]\nend\nprob = OneDManifoldProblem(timeTmap, para)\nmanifold = growmanifold(prob, segment, 7)\nfunction manifold_plot(data)\n    figure = Figure()\n    axes = Axis(figure[1,1])\n    for k in eachindex(data)\n        points = data[k].u\n        lines!(axes, first.(points), last.(points))\n    end\n    figure\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_two.html#光滑两维流形","page":"光滑两维流形","title":"光滑两维流形","text":"","category":"section"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"在本质上, 我们并没有引入新的算法, 计算二维流形的核心函数跟一维流形的核心函数是一样的. 我们只是将二维流形表示为离得足够近的一维的圆圈.","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie","category":"page"},{"location":"smooth_two.html#自治向量场:-Lorenz-流形","page":"光滑两维流形","title":"自治向量场: Lorenz 流形","text":"","category":"section"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"首先加载需要的包, 并定义 Lorenz 向量场:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nfunction lorenz(x, p, t)\n    σ, ρ, β = p\n    v = SA[σ*(x[2]-x[1]),\n        ρ*x[1]-x[2]-x[1]*x[3],\n        x[1]*x[2]-β*x[3]\n    ]\n    v / sqrt(0.1 + norm(v)^2)\nend","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"值得注意的是, 我们对向量场进行了一个近似的归一化, 使得向量场的模长保持在一个很小的范围内. 这样可以保证流形的扩张是均匀的. 在经典参数下:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"para = [10.0, 28.0, 8/3]","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"原点这个平衡点的 Jacobi 矩阵具有两个稳定方向, 这个稳定方向分别是:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"function eigenv(p)\n    σ, ρ, β = p\n    [SA[0.0, 0.0, 1.0], SA[-(-1 + σ + sqrt(1 - 2 * σ + 4 * ρ * σ + σ^2))/(2*ρ), 1, 0]]\nend\neigenv(para)","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"那么我们可以创建一个 Saddle 结构体来存储这个鞍点:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"saddle = Saddle(SA[0, 0, 0.0], eigenv(para), [1.0, 1.0])","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"这里特征值的大小可以随意指定, 不会影响计算结果. 由于计算的是稳定流形, 我们需要将流进行反向演化. 定义如下映射:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"function lorenz_map(x, p)\n    prob = ODEProblem{false}(lorenz, x, (0.0, -1.0), p)\n    sol = solve(prob, Vern9(), abstol = 1e-10)\n    sol[end]\nend","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"现在我们可以创建问题:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"prob = VTwoDManifoldProblem(lorenz_map, para, d=1.0, amax=1.0, dsmin=1e-3)","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"这些关键字参数的含义可参考 VTwoDManifoldProblem.","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"与一维流形类似, 同样需要一个局部流形才能进行延拓. 相应的创建局部流形的函数为 gen_disk:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"disk = gen_disk(saddle, r=1.0)","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"关于函数 gen_disk 的详细介绍请参考 gen_disk. 现在我们可以进行延拓了:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"manifold = growmanifold(prob, disk, 200)","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"我们同样可以定义一个绘图函数来进行绘制结果:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"using CairoMakie\nfunction manifold_plot(annulus)\n    fig = Figure()\n    axes = LScene(fig[1, 1], show_axis=false, scenekw=(backgroundcolor=:white, clear=true))\n    second(x) = x[2]\n    for i in eachindex(annulus)\n        points = annulus[i].u\n        lines!(axes, first.(points), second.(points), last.(points), fxaa=true)\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"完整代码:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nfunction lorenz(x, p, t)\n    σ, ρ, β = p\n    v = SA[σ*(x[2]-x[1]),\n        ρ*x[1]-x[2]-x[1]*x[3],\n        x[1]*x[2]-β*x[3]\n    ]\n    v / sqrt(0.1 + norm(v)^2)\nend\nfunction eigenv(p)\n    σ, ρ, β = p\n    [SA[0.0, 0.0, 1.0], SA[-(-1 + σ + sqrt(1 - 2 * σ + 4 * ρ * σ + σ^2))/(2*ρ), 1, 0]]\nend\npara = [10.0, 28.0, 8/3]\nsaddle = Saddle(SA[0.0, 0.0, 0.0], eigenv(para), [1.0, 1.0])\nprob = VTwoDManifoldProblem(lorenz, para, d=1.0, amax=1.0, dsmin=1e-3)\ndisk = gen_disk(saddle, r=1.0)\nmanifold = growmanifold(prob, disk, 200)\nfunction manifold_plot(annulus)\n    fig = Figure()\n    axes = LScene(fig[1, 1], show_axis=false, scenekw=(backgroundcolor=:white, clear=true))\n    second(x) = x[2]\n    for i in eachindex(annulus)\n        points = annulus[i].u\n        lines!(axes, first.(points), second.(points), last.(points), fxaa=true)\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"},{"location":"smooth_two.html#非线性映射","page":"光滑两维流形","title":"非线性映射","text":"","category":"section"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"考虑如下的非线性映射:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"f(X)=varphicircLambdacircvarphi^-1(X)","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"其中 varphi(xyz)=(xyz-alpha x^2-beta y^2) 是一个非线性映射, Lambda 是一个对角矩阵, 其对角元可用来控制映射 f 在原点附近的 Jacobi 矩阵. 我们直接给出计算其不变流形的代码:","category":"page"},{"location":"smooth_two.html","page":"光滑两维流形","title":"光滑两维流形","text":"using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie\nconst Λ = SDiagonal(SA[2.1, 6.3, 0.6])\nφ(x, p)= SA[x[1],x[2],x[3]-p[1]*x[1]^2-p[2]*x[2]^2]\niφ(x, p)= SA[x[1],x[2],x[3]+p[1]*x[1]^2+p[2]*x[2]^2]\nf(x,p) = φ(Λ*iφ(x, p),p)\n\npara = [1.2,-1.2]\nsaddle = Saddle(SA[0.0, 0.0, 0.0], [SA[1.0, 0.0, 0.0], SA[0.0, 1.0, 0.0]], [2.1, 6.3])\nprob = TwoDManifoldProblem(f, para, dcircle=0.05, d = 0.02, dsmin=1e-3)\n\ndisk = gen_disk(saddle, times=4, r= 0.05)\nmanifold = growmanifold(prob, disk, 3)\nfunction manifold_plot(data)\n    fig = Figure()\n    axes = Axis3(fig[1,1])\n    second(x) = x[2]\n    for k in eachindex(data)\n        for j in eachindex(data[k])\n            points=data[k][j].u\n            scatter!(axes,first.(points),second.(points),last.(points),fxaa=true)\n        end\n    end\n    fig\nend\nmanifold_plot(manifold.data)","category":"page"}]
}

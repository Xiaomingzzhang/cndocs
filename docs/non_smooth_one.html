<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>非光滑一维流形 · InvariantManifolds.jl</title><meta name="title" content="非光滑一维流形 · InvariantManifolds.jl"/><meta property="og:title" content="非光滑一维流形 · InvariantManifolds.jl"/><meta property="twitter:title" content="非光滑一维流形 · InvariantManifolds.jl"/><meta name="description" content="Documentation for InvariantManifolds.jl."/><meta property="og:description" content="Documentation for InvariantManifolds.jl."/><meta property="twitter:description" content="Documentation for InvariantManifolds.jl."/><meta property="og:url" content="https://Xiaomingzzhang.github.io/InvariantManifolds.jl/non_smooth_one.html"/><meta property="twitter:url" content="https://Xiaomingzzhang.github.io/InvariantManifolds.jl/non_smooth_one.html"/><link rel="canonical" href="https://Xiaomingzzhang.github.io/InvariantManifolds.jl/non_smooth_one.html"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="InvariantManifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">InvariantManifolds.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">主页</a></li><li><a class="tocitem" href="smooth_one.html">开始使用: 一维光滑流形</a></li><li><a class="tocitem" href="smooth_two.html">光滑两维流形</a></li><li class="is-active"><a class="tocitem" href="non_smooth_one.html">非光滑一维流形</a><ul class="internal"><li><a class="tocitem" href="#分段光滑系统"><span>分段光滑系统</span></a></li><li><a class="tocitem" href="#碰撞系统"><span>碰撞系统</span></a></li><li><a class="tocitem" href="#分段光滑与碰撞的组合的-ODE-系统"><span>分段光滑与碰撞的组合的 ODE 系统</span></a></li></ul></li><li><a class="tocitem" href="non_smooth_two.html">非光滑两维流形</a></li><li><a class="tocitem" href="api.html">类型与函数</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="non_smooth_one.html">非光滑一维流形</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="non_smooth_one.html">非光滑一维流形</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Xiaomingzzhang/cndocs" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Xiaomingzzhang/cndocs/blob/master/src/non_smooth_one.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="非光滑一维流形"><a class="docs-heading-anchor" href="#非光滑一维流形">非光滑一维流形</a><a id="非光滑一维流形-1"></a><a class="docs-heading-anchor-permalink" href="#非光滑一维流形" title="Permalink"></a></h1><p>或许这个软件包最值得注意的地方就是其可以计算非光滑流形. 目前, 支持两类系统的非光滑流形计算:</p><ul><li>时间周期的非光滑微分方程的一维流形计算</li><li>非光滑自治系统的二维流形计算</li></ul><p>其中流形值得都是鞍点的不变流形, 前者需要取时间周期映射, 后者则需要取固定步长的时间-<span>$T$</span>-映射. 这两类系统中的非光滑因素可以是多种多样的, 包括分段光滑, 碰撞, 以及它们之间的组合. 这三类非光滑系统无需用户自己求解, 我们提供了三个封装的结构体:</p><ul><li><a href="api.html#InvariantManifolds.PiecewiseV"><code>PiecewiseV</code></a></li><li><a href="api.html#InvariantManifolds.BilliardV"><code>BilliardV</code></a></li><li><a href="api.html#InvariantManifolds.PiecewiseImpactV"><code>PiecewiseImpactV</code></a></li></ul><p>并使用 <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> 中的 Callback 功能来进行时间映射的计算. 下面将以三个例子来介绍这三类非光滑系统不变流形的计算方法.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>关于非光滑流形的计算严重依赖于求解 ODE 的算法与精度, 当求解失败或效果不佳时, 可以尝试更换算法, 提高求解 ODE 的精度, 或者降低 <a href="api.html#InvariantManifolds.NSOneDManifoldProblem"><code>NSOneDManifoldProblem</code></a> 中的参数 <code>ϵ</code>, <code>d</code>, <code>amax</code> 的值的大小.</p></div></div><h2 id="分段光滑系统"><a class="docs-heading-anchor" href="#分段光滑系统">分段光滑系统</a><a id="分段光滑系统-1"></a><a class="docs-heading-anchor-permalink" href="#分段光滑系统" title="Permalink"></a></h2><p>考虑一个简单的分段光滑系统:</p><p class="math-container">\[\begin{aligned}
\dot{x}&amp;=y,\\
\dot{y}&amp;=f(x) + \epsilon \sin(2\pi t),
\end{aligned}\]</p><p>其中</p><p class="math-container">\[f(x) =
\begin{cases}
-k_1 x&amp; \text{if } x &lt; -d,\\
k_2 x &amp; \text{if } -d&lt;x&lt;d,\\
-k_3 x&amp; \text{if } x &gt; d.
\end{cases}\]</p><p class="math-container">\[k_1,k_2,k_3,d&gt;0\]</p><p>都为正的常数. 下面我们将计算时间周期映射的不变流形. 注意到当周期扰动很小时, 鞍点应当很接近原点.</p><p>首先加载用到的程序包</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>接着定义分段光滑的矢量场:</p><pre><code class="language-julia hljs">f1(x, p, t) = SA[x[2], p[1]*x[1]+p[4]*sin(2pi * t)]
f2(x, p, t) = SA[x[2], -p[2]*x[1]+p[4]*sin(2pi * t)]
f3(x, p, t) = SA[x[2], -p[3]*x[1]+p[4]*sin(2pi * t)]

hyper1(x, p, t) = x[1] - p[5]
hyper2(x, p, t) = x[1] + p[5]

dom1(x, p, t) = -p[5] &lt; x[1] &lt; p[5]
dom2(x, p, t) = x[1] &gt; p[5]
dom3(x, p, t) = x[1] &lt; -p[5]

vectorfield = PiecewiseV((f1, f2, f3), (dom1, dom2, dom3), (hyper1, hyper2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PiecewiseV: 
fs: (Main.f1, Main.f2, Main.f3)
regions: (Main.dom1, Main.dom2, Main.dom3)
hypers: (Main.hyper1, Main.hyper2)
n: 0</code></pre><p>传递给 <code>PiecewiseV</code> 这个结构体的参数分别为: 矢量场, 它们所在的区域, 以及分割这些区域的超平面. 更多细节可参考 <a href="api.html#InvariantManifolds.PiecewiseV"><code>PiecewiseV</code></a>.</p><p>接下来我们将求解时间周期映射的关键信息封装到另外一个结构体 <a href="api.html#InvariantManifolds.NSSetUp"><code>NSSetUp</code></a> 中:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; setup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36">NSSetUp:</span>
f: PiecewiseV{Tuple{typeof(Main.f1), typeof(Main.f2), typeof(Main.f3)}, Tuple{typeof(Main.dom1), typeof(Main.dom2), typeof(Main.dom3)}, Tuple{typeof(Main.hyper1), typeof(Main.hyper2)}}((Main.f1, Main.f2, Main.f3), (Main.dom1, Main.dom2, Main.dom3), (Main.hyper1, Main.hyper2), 0)
timespan: (0.0, 1.0)</code></pre><p>其中函数 <a href="api.html#InvariantManifolds.setmap-Union{Tuple{T}, Tuple{PiecewiseV, Tuple{T, T}, Any}} where T"><code>setmap</code></a> 用于封装时间映射的计算信息. 现在我们已经定义好求解时间周期映射的一切了.</p><p>接下来为了生成局部流形. 我们同样需要定位鞍点以及其不稳定特征向量. 取定参数:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; para = para = [2, 5, 5, 0.6, 2]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 2.0
 5.0
 5.0
 0.6
 2.0</code></pre><p>由于扰动是很小的, 鞍型的周期轨道应该仍然在 <code>dom1</code> 中. 因此我们可以使用 <code>findsaddle</code> 来计算鞍点的位置:</p><pre><code class="language-julia hljs">function df1(x, p, t)
    SA[0 1; p[1] 0]
end
initialguess = SA[0.0, 0.0]
saddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Saddle{2,Float64,Float64}: 
saddle: [1.3120846754625683e-11, -0.0908885006640104]
unstable_directions: StaticArraysCore.SVector{2, Float64}[[0.5773502691896258, 0.816496580927726]]
unstable_eigen_values: [4.113250379341709]</code></pre><p>接下来创建问题, 生成局部流形, 并进行延拓</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; prob = NSOneDManifoldProblem(setup, para, ϵ = 1e-3)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36">NSOneDManifoldProblem:</span>
f: NSSetUp generated by non-smooth vector field: PiecewiseV{Tuple{typeof(Main.f1), typeof(Main.f2), typeof(Main.f3)}, Tuple{typeof(Main.dom1), typeof(Main.dom2), typeof(Main.dom3)}, Tuple{typeof(Main.hyper1), typeof(Main.hyper2)}}((Main.f1, Main.f2, Main.f3), (Main.dom1, Main.dom2, Main.dom3), (Main.hyper1, Main.hyper2), 0)
para: [2.0, 5.0, 5.0, 0.6, 2.0]
amax: 0.5
d: 0.001
ϵ: 0.001
dsmin: 0.0001</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; segment = gen_segment(saddle)</code><code class="nohighlight hljs ansi" style="display:block;">150-element Vector{StaticArraysCore.SVector{2, Float64}}:
 [1.3120846754625683e-11, -0.0908885006640104]
 [3.874835333491561e-5, -0.09083370223576022]
 [7.749669354898446e-5, -0.09077890380751004]
 [0.00011624503376305329, -0.09072410537925985]
 [0.00015499337397712216, -0.09066930695100966]
 [0.000193741714191191, -0.09061450852275948]
 [0.00023249005440525983, -0.0905597100945093]
 [0.00027123839461932873, -0.09050491166625912]
 [0.0003099867348333976, -0.09045011323800893]
 [0.00034873507504746637, -0.09039531480975875]
 ⋮
 [0.0054635159833045545, -0.0831619222807346]
 [0.005502264323518622, -0.08310712385248442]
 [0.005541012663732692, -0.08305232542423424]
 [0.00557976100394676, -0.08299752699598406]
 [0.00561850934416083, -0.08294272856773387]
 [0.005657257684374898, -0.08288793013948369]
 [0.005696006024588967, -0.0828331317112335]
 [0.005734754364803036, -0.08277833328298333]
 [0.005773502705017105, -0.08272353485473313]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; manifold = growmanifold(prob, segment, 8)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36"><span class="sgr1">Non-smooth one-dimensional manifold</span></span>
<span class="sgr36">Curves number: </span>30
<span class="sgr36">Points number: </span>168633
<span class="sgr36">Flaw points number: </span>10
<span class="sgr36">Distance failed points number: </span>0
<span class="sgr36">Curvature failed points number: </span>10</code></pre><p>注意到, <code>manifold.data</code> 的数据类型是 <code>Vector{Vector{S}}</code>, 其中 <code>S</code> 是插值函数. 所以绘制结果需要使用如下函数:</p><pre><code class="language-julia hljs">using CairoMakie
function manifold_plot(data)
    fig = Figure()
    axes = Axis(fig[1,1])
    for k in eachindex(data)
        for j in eachindex(data[k])
            points=data[k][j].u
            lines!(axes,first.(points),last.(points))
        end
    end
    fig
end
manifold_plot(manifold.data)</code></pre><img src="non_smooth_one-dbbaa3e9.png" alt="Example block output"/><h2 id="碰撞系统"><a class="docs-heading-anchor" href="#碰撞系统">碰撞系统</a><a id="碰撞系统-1"></a><a class="docs-heading-anchor-permalink" href="#碰撞系统" title="Permalink"></a></h2><p>考虑如下的受到激励的倒摆方程:</p><p class="math-container">\[\begin{aligned}
\dot{x}&amp;= y,\\
\dot{y}&amp;= \sin(x) - \epsilon \cos(2\pi t),
\end{aligned}\]</p><p>假设倒摆两边存在墙壁: 当 <span>$x=\xi$</span> 或者 <span>$x=-\xi$</span> 时, 有 <span>$y\rightarrow - ry$</span>. 同样地, 需要先构建非光滑矢量场</p><pre><code class="language-julia hljs">f(x, p, t) = SA[x[2], sin(x[1])-p[1]*cos(2 * pi * t)]

hyper1(x, p, t) = x[1] + p[2]
hyper2(x, p, t) = x[1] - p[2]

rule1(x, p, t) = SA[x[1], -p[3]*x[2]]
rule2(x, p, t) = SA[x[1], -p[3]*x[2]]

vectorfield = BilliardV(f, (hyper1, hyper2), (rule1, rule2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BilliardV{typeof(Main.f), Tuple{typeof(Main.hyper1), typeof(Main.hyper2)}, Tuple{typeof(Main.rule1), typeof(Main.rule2)}}(Main.f, (Main.hyper1, Main.hyper2), (Main.rule1, Main.rule2))</code></pre><p>接着封装求解时间周期映射的信息:</p><pre><code class="language-julia hljs">setup = setmap(vectorfield, (0.0, 1.0), Vern9(), abstol=1e-10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36">NSSetUp:</span>
f: BilliardV{typeof(Main.f), Tuple{typeof(Main.hyper1), typeof(Main.hyper2)}, Tuple{typeof(Main.rule1), typeof(Main.rule2)}}(Main.f, (Main.hyper1, Main.hyper2), (Main.rule1, Main.rule2))
timespan: (0.0, 1.0)</code></pre><p>寻找鞍点:</p><pre><code class="language-julia hljs">function df(x, p, t)
    SA[0 1; cos(x[1]) 0]
end
para = [0.2, pi / 4, 0.98]
initialguess = SA[0.0, 0.0]
saddle = findsaddle(f, df, (0.0,1.0), initialguess, para, abstol=1e-10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Saddle{2,Float64,Float64}: 
saddle: [0.004940905039667357, 3.526850741022572e-11]
unstable_directions: StaticArraysCore.SVector{2, Float64}[[0.7071078867575611, 0.7071056756138056]]
unstable_eigen_values: [2.7182735331462027]</code></pre><p>接下来创建问题, 生成局部流形, 并进行延拓</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; prob = NSOneDManifoldProblem(setup, para)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36">NSOneDManifoldProblem:</span>
f: NSSetUp generated by non-smooth vector field: BilliardV{typeof(Main.f), Tuple{typeof(Main.hyper1), typeof(Main.hyper2)}, Tuple{typeof(Main.rule1), typeof(Main.rule2)}}(Main.f, (Main.hyper1, Main.hyper2), (Main.rule1, Main.rule2))
para: [0.2, 0.7853981633974483, 0.98]
amax: 0.5
d: 0.001
ϵ: 1.0e-5
dsmin: 0.0001</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; segment = gen_segment(saddle)</code><code class="nohighlight hljs ansi" style="display:block;">150-element Vector{StaticArraysCore.SVector{2, Float64}}:
 [0.004940905039667357, 3.526850741022572e-11]
 [0.004988361944818871, 4.745679202111181e-5]
 [0.005035818849970385, 9.491354877371621e-5]
 [0.005083275755121899, 0.0001423703055263206]
 [0.005130732660273414, 0.00018982706227892502]
 [0.005178189565424928, 0.00023728381903152942]
 [0.005225646470576442, 0.0002847405757841338]
 [0.005273103375727956, 0.0003321973325367382]
 [0.00532056028087947, 0.0003796540892893426]
 [0.005368017186030984, 0.00042711084604194697]
 ⋮
 [0.011632328666030855, 0.006691402737385728]
 [0.011679785571182367, 0.006738859494138332]
 [0.011727242476333883, 0.006786316250890937]
 [0.011774699381485397, 0.006833773007643541]
 [0.011822156286636912, 0.006881229764396146]
 [0.011869613191788425, 0.00692868652114875]
 [0.01191707009693994, 0.0069761432779013545]
 [0.011964527002091453, 0.007023600034653958]
 [0.012011983907242969, 0.007071056791406564]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; manifold = growmanifold(prob, segment, 11)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36"><span class="sgr1">Non-smooth one-dimensional manifold</span></span>
<span class="sgr36">Curves number: </span>38
<span class="sgr36">Points number: </span>98311
<span class="sgr36">Flaw points number: </span>15
<span class="sgr36">Distance failed points number: </span>0
<span class="sgr36">Curvature failed points number: </span>15</code></pre><p>最后绘制结果: </p><pre><code class="language-julia hljs">manifold_plot(manifold.data)</code></pre><img src="non_smooth_one-8def44cb.png" alt="Example block output"/><h2 id="分段光滑与碰撞的组合的-ODE-系统"><a class="docs-heading-anchor" href="#分段光滑与碰撞的组合的-ODE-系统">分段光滑与碰撞的组合的 ODE 系统</a><a id="分段光滑与碰撞的组合的-ODE-系统-1"></a><a class="docs-heading-anchor-permalink" href="#分段光滑与碰撞的组合的-ODE-系统" title="Permalink"></a></h2><p>现在考虑同时存在分段光滑与碰撞的 ODE 系统:</p><p class="math-container">\[\begin{aligned}
\dot{x}&amp;=y,\\
\dot{y}&amp;=f(x) + \epsilon \sin(2\pi t),
\end{aligned}\]</p><p>其中</p><p class="math-container">\[f(x) =
\begin{cases}
-k_1 x&amp; \text{if } x &lt; -d,\\
k_2 x &amp; \text{if } -d&lt;x&lt;d
\end{cases}\]</p><p class="math-container">\[k_1,k_2,d&gt;0\]</p><p>都为正的常数. 当 <span>$x=d$</span> 时, 有 <span>$\dot{y}-&gt;-r\dot{y}$</span>. 下面我们将计算时间周期映射的不变流形. 注意到当周期扰动很小时, 鞍点应当很接近原点. 首先加载用到的程序包</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using InvariantManifolds, LinearAlgebra, StaticArrays, OrdinaryDiffEq, CairoMakie</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>接着定义非光滑矢量场:</p><pre><code class="language-julia hljs">f1(x, p, t) = SA[x[2], p[1]*x[1]+p[3]*sin(2pi * t)]
f2(x, p, t) = SA[x[2], -p[2]*x[1]+p[3]*sin(2pi * t)]

hyper1(x, p, t) = x[1] - p[4]
hyper2(x, p, t) = x[1] + p[4]

dom1(x, p, t) = -p[4] &lt; x[1] &lt; p[4]
dom2(x, p, t) = x[1] &lt; -p[4]

impact_rule(x, p, t) = SA[x[1], -p[5]*x[2]]
id(x,p,t) = x

vectorfield = PiecewiseImpactV((f1, f2), (dom1, dom2), (hyper1, hyper2), (impact_rule, id), [1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PiecewiseImpactV{Tuple{typeof(Main.f1), typeof(Main.f2)}, Tuple{typeof(Main.hyper1), typeof(Main.hyper2)}, Tuple{typeof(Main.impact_rule), typeof(Main.id)}, Tuple{typeof(Main.dom1), typeof(Main.dom2)}}((Main.f1, Main.f2), (Main.dom1, Main.dom2), (Main.hyper1, Main.hyper2), (Main.impact_rule, Main.id), [1], 0)</code></pre><p>传递给 <code>PiecewiseImpactV</code> 这个结构体的参数分别为: 矢量场, 它们所在的区域, 以及分割这些区域的超平面, 作用在超平面上的规则, 以及具有碰撞效应的那些规则列表. 更多细节可参考 <a href="api.html#InvariantManifolds.PiecewiseImpactV"><code>PiecewiseImpactV</code></a>.</p><p>接下来我们将求解时间周期映射的关键信息封装到另外一个结构体 <a href="api.html#InvariantManifolds.NSSetUp"><code>NSSetUp</code></a> 中:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; setup = setmap(vectorfield, (0.0, 1.0), Tsit5(), abstol=1e-8)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36">NSSetUp:</span>
f: PiecewiseImpactV{Tuple{typeof(Main.f1), typeof(Main.f2)}, Tuple{typeof(Main.hyper1), typeof(Main.hyper2)}, Tuple{typeof(Main.impact_rule), typeof(Main.id)}, Tuple{typeof(Main.dom1), typeof(Main.dom2)}}((Main.f1, Main.f2), (Main.dom1, Main.dom2), (Main.hyper1, Main.hyper2), (Main.impact_rule, Main.id), [1], 0)
timespan: (0.0, 1.0)</code></pre><p>其中函数 <a href="api.html#InvariantManifolds.setmap-Union{Tuple{T}, Tuple{PiecewiseV, Tuple{T, T}, Any}} where T"><code>setmap</code></a> 用于封装时间映射的计算信息. 现在我们已经定义好求解时间周期映射的一切了.</p><p>接下来为了生成局部流形. 我们同样需要定位鞍点以及其不稳定特征向量. 取定参数:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; para = [2, 5, 0.6, 2, 0.98]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 2.0
 5.0
 0.6
 2.0
 0.98</code></pre><p>由于扰动是很小的, 鞍型的周期轨道应该仍然在 <code>dom1</code> 中. 因此我们可以使用 <code>findsaddle</code> 来计算鞍点的位置:</p><pre><code class="language-julia hljs">function df1(x, p, t)
    SA[0 1; p[1] 0]
end
initialguess = SA[0.0, 0.0]
saddle = findsaddle(f1, df1, (0.0,1.0), initialguess, para, abstol=1e-10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Saddle{2,Float64,Float64}: 
saddle: [1.3120846754625683e-11, -0.0908885006640104]
unstable_directions: StaticArraysCore.SVector{2, Float64}[[0.5773502691896258, 0.816496580927726]]
unstable_eigen_values: [4.113250379341709]</code></pre><p>接下来创建问题, 生成局部流形, 并进行延拓</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; prob = NSOneDManifoldProblem(setup, para, ϵ = 1e-3)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36">NSOneDManifoldProblem:</span>
f: NSSetUp generated by non-smooth vector field: PiecewiseImpactV{Tuple{typeof(Main.f1), typeof(Main.f2)}, Tuple{typeof(Main.hyper1), typeof(Main.hyper2)}, Tuple{typeof(Main.impact_rule), typeof(Main.id)}, Tuple{typeof(Main.dom1), typeof(Main.dom2)}}((Main.f1, Main.f2), (Main.dom1, Main.dom2), (Main.hyper1, Main.hyper2), (Main.impact_rule, Main.id), [1], 0)
para: [2.0, 5.0, 0.6, 2.0, 0.98]
amax: 0.5
d: 0.001
ϵ: 0.001
dsmin: 0.0001</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; segment = gen_segment(saddle)</code><code class="nohighlight hljs ansi" style="display:block;">150-element Vector{StaticArraysCore.SVector{2, Float64}}:
 [1.3120846754625683e-11, -0.0908885006640104]
 [3.874835333491561e-5, -0.09083370223576022]
 [7.749669354898446e-5, -0.09077890380751004]
 [0.00011624503376305329, -0.09072410537925985]
 [0.00015499337397712216, -0.09066930695100966]
 [0.000193741714191191, -0.09061450852275948]
 [0.00023249005440525983, -0.0905597100945093]
 [0.00027123839461932873, -0.09050491166625912]
 [0.0003099867348333976, -0.09045011323800893]
 [0.00034873507504746637, -0.09039531480975875]
 ⋮
 [0.0054635159833045545, -0.0831619222807346]
 [0.005502264323518622, -0.08310712385248442]
 [0.005541012663732692, -0.08305232542423424]
 [0.00557976100394676, -0.08299752699598406]
 [0.00561850934416083, -0.08294272856773387]
 [0.005657257684374898, -0.08288793013948369]
 [0.005696006024588967, -0.0828331317112335]
 [0.005734754364803036, -0.08277833328298333]
 [0.005773502705017105, -0.08272353485473313]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; manifold = growmanifold(prob, segment, 9)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36"><span class="sgr1">Non-smooth one-dimensional manifold</span></span>
<span class="sgr36">Curves number: </span>52
<span class="sgr36">Points number: </span>346533
<span class="sgr36">Flaw points number: </span>13
<span class="sgr36">Distance failed points number: </span>0
<span class="sgr36">Curvature failed points number: </span>13</code></pre><p>注意到, <code>manifold.data</code> 的数据类型是 <code>Vector{Vector{S}}</code>, 其中 <code>S</code> 是插值函数. 所以绘制结果需要使用如下函数:</p><pre><code class="language-julia hljs">using CairoMakie
function manifold_plot(data)
    fig = Figure()
    axes = Axis(fig[1,1])
    for k in eachindex(data)
        for j in eachindex(data[k])
            points=data[k][j].u
            lines!(axes,first.(points),last.(points))
        end
    end
    fig
end
manifold_plot(manifold.data)</code></pre><img src="non_smooth_one-ce4e251e.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="smooth_two.html">« 光滑两维流形</a><a class="docs-footer-nextpage" href="non_smooth_two.html">非光滑两维流形 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Sunday 2 March 2025 12:02">Sunday 2 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
